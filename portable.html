<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Rupture Production</title>
  <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>&#x1f3ed;</text></svg>" />
  <style>
    /* ===== Reset & Base ===== */
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    :root {
      --dark-900: #0d0d1a;
      --dark-800: #13132b;
      --dark-700: #1a1a3e;
      --dark-600: #242450;
      --dark-500: #2e2e62;
      --accent-blue: #4a9eff;
      --accent-green: #22c55e;
      --accent-amber: #f59e0b;
      --gray-100: #f3f4f6;
      --gray-200: #e5e7eb;
      --gray-300: #d1d5db;
      --gray-400: #9ca3af;
      --gray-500: #6b7280;
      --gray-600: #4b5563;
      --red-300: #fca5a5;
      --red-400: #f87171;
      --red-700: #b91c1c;
      --red-900-30: rgba(127, 29, 29, 0.3);
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      background: var(--dark-900);
      color: var(--gray-100);
      min-height: 100vh;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    ::-webkit-scrollbar { width: 8px; height: 8px; }
    ::-webkit-scrollbar-track { background: var(--dark-800); }
    ::-webkit-scrollbar-thumb { background: var(--dark-500); border-radius: 9999px; }
    ::-webkit-scrollbar-thumb:hover { background: var(--accent-blue); }

    /* ===== Layout ===== */
    .app { min-height: 100vh; display: flex; flex-direction: column; }

    header {
      background: var(--dark-800);
      border-bottom: 1px solid var(--dark-600);
      position: sticky; top: 0; z-index: 10;
    }

    .header-inner {
      max-width: 80rem; margin: 0 auto; padding: 0.75rem 1rem;
      display: flex; align-items: center; justify-content: space-between;
    }

    .header-left { display: flex; align-items: center; gap: 0.75rem; }

    .logo { font-size: 1.25rem; font-weight: 700; color: var(--gray-100); }
    .logo-accent { color: var(--accent-blue); }

    .active-save-label {
      font-size: 0.875rem; color: var(--gray-500);
    }

    .back-btn {
      background: none; border: none; cursor: pointer;
      font-size: 0.875rem; color: var(--gray-400);
      display: flex; align-items: center; gap: 0.25rem;
      transition: color 0.15s;
    }
    .back-btn:hover { color: var(--accent-blue); }
    .back-btn svg { width: 1rem; height: 1rem; }

    /* ===== Tabs ===== */
    .tabs-container { max-width: 80rem; margin: 0 auto; padding: 0 1rem; }
    .tabs-nav { display: flex; gap: 0.25rem; }

    .tab-btn {
      background: none; border: none; cursor: pointer;
      padding: 0.625rem 1rem; font-size: 0.875rem; font-weight: 500;
      border-radius: 0.5rem 0.5rem 0 0;
      color: var(--gray-400); position: relative;
      transition: color 0.15s, background 0.15s;
    }
    .tab-btn:hover { color: var(--gray-200); background: var(--dark-700); }
    .tab-btn.active { background: var(--dark-900); color: var(--accent-blue); }
    .tab-btn.active::after {
      content: ''; position: absolute; bottom: 0; left: 0; right: 0;
      height: 2px; background: var(--accent-blue);
    }

    .tab-badge {
      margin-left: 0.5rem; padding: 0.125rem 0.375rem;
      border-radius: 0.25rem; font-size: 0.75rem;
    }
    .tab-btn .tab-badge { background: var(--dark-600); color: var(--gray-500); }
    .tab-btn.active .tab-badge { background: rgba(74, 158, 255, 0.2); color: var(--accent-blue); }

    /* ===== Main ===== */
    main { flex: 1; max-width: 80rem; margin: 0 auto; width: 100%; padding: 1.5rem 1rem; }

    footer {
      background: var(--dark-800); border-top: 1px solid var(--dark-600);
      padding: 0.75rem; text-align: center; font-size: 0.875rem; color: var(--gray-500);
    }

    /* ===== Error ===== */
    .error-banner {
      background: var(--red-900-30); border: 1px solid var(--red-700);
      border-radius: 0.5rem; padding: 0.75rem 1rem; margin-bottom: 1rem;
      color: var(--red-300);
    }

    /* ===== Loading ===== */
    .loading-overlay {
      position: fixed; inset: 0; background: rgba(13, 13, 26, 0.8);
      z-index: 50; display: flex; align-items: center; justify-content: center;
    }
    .loading-card {
      background: var(--dark-800); border-radius: 0.75rem; padding: 2rem;
      display: flex; flex-direction: column; align-items: center; gap: 1rem;
      box-shadow: 0 25px 50px -12px rgba(0,0,0,0.5);
    }
    .spinner {
      width: 3rem; height: 3rem; border-radius: 50%;
      border: 2px solid transparent; border-bottom-color: var(--accent-blue);
      animation: spin 1s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    /* ===== Save Picker ===== */
    .picker-container {
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      padding: 4rem 1rem; text-align: center;
    }
    .picker-icon {
      width: 5rem; height: 5rem; margin-bottom: 1.5rem; color: var(--accent-blue);
      opacity: 0.6;
    }
    .picker-title { font-size: 1.25rem; font-weight: 600; color: var(--gray-200); margin-bottom: 0.5rem; }
    .picker-subtitle { font-size: 0.875rem; color: var(--gray-500); margin-bottom: 2rem; max-width: 28rem; }

    .file-input-wrapper {
      position: relative; display: inline-block;
    }
    .file-input-wrapper input[type="file"] {
      position: absolute; inset: 0; opacity: 0; cursor: pointer;
    }
    .file-btn {
      display: inline-flex; align-items: center; gap: 0.5rem;
      padding: 0.75rem 1.5rem; font-size: 1rem; font-weight: 600;
      background: var(--accent-blue); color: #fff; border: none;
      border-radius: 0.5rem; cursor: pointer; transition: opacity 0.15s;
    }
    .file-btn:hover { opacity: 0.9; }
    .file-btn svg { width: 1.25rem; height: 1.25rem; }

    .drop-hint {
      margin-top: 1rem; font-size: 0.875rem; color: var(--gray-500);
    }

    .drag-active {
      outline: 2px dashed var(--accent-blue);
      outline-offset: -4px;
      background: rgba(74, 158, 255, 0.05);
    }

    /* ===== Summary Cards ===== */
    .summary-grid {
      display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem;
      margin-bottom: 1.5rem;
    }
    .summary-grid-with-map { grid-template-columns: repeat(4, 1fr); }
    @media (max-width: 640px) { .summary-grid, .summary-grid-with-map { grid-template-columns: 1fr; } }

    .summary-card {
      background: var(--dark-800); border-radius: 0.5rem; padding: 1rem;
      cursor: pointer; transition: background 0.15s;
    }
    .summary-card:hover { background: var(--dark-700); }
    .summary-label { font-size: 0.875rem; color: var(--gray-400); }
    .summary-value { font-size: 1.5rem; font-weight: 700; }
    .summary-sub { font-size: 0.75rem; color: var(--gray-500); margin-top: 0.25rem; }

    .color-blue { color: var(--accent-blue); }
    .color-green { color: var(--accent-green); }
    .color-amber { color: var(--accent-amber); }
    .color-red { color: #ef4444; }
    tr.shortfall-row { background: rgba(239, 68, 68, 0.08); }
    .shortfall-expand {
      display: inline-block;
      width: 1rem;
      margin-right: 0.25rem;
      cursor: pointer;
      color: var(--gray-500);
      transition: transform 0.2s;
      vertical-align: middle;
      user-select: none;
    }
    .shortfall-expand::before { content: '\25B6'; font-size: 0.65rem; }
    .shortfall-expand:hover { color: var(--gray-300); }
    .shortfall-expand-open { transform: rotate(90deg); }
    .shortfall-detail-row { display: none; }
    .shortfall-detail-row.shortfall-detail-visible { display: table-row; }
    .shortfall-detail-cell {
      padding: 0.5rem 1rem 0.75rem 2.25rem !important;
      background: var(--panel-bg);
      border-bottom: 1px solid var(--border);
      color: var(--gray-400);
      font-size: 0.875rem;
    }
    .shortfall-consumed-by-label { margin-right: 0.5rem; color: var(--gray-500); }
    .shortfall-consumed-by-item {
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
      margin-right: 1rem;
      white-space: nowrap;
    }
    .shortfall-consumed-by-item .mono { color: var(--accent-green); margin-left: 0.25rem; }

    /* ===== Search Bar ===== */
    .search-wrapper { position: relative; flex: 1; max-width: 28rem; }
    .search-wrapper svg.search-icon {
      position: absolute; left: 0.75rem; top: 50%; transform: translateY(-50%);
      width: 1rem; height: 1rem; color: var(--gray-400);
    }
    .search-input {
      width: 100%; padding: 0.5rem 2.5rem 0.5rem 2.5rem;
      background: var(--dark-800); border: 1px solid var(--dark-500);
      border-radius: 0.5rem; color: var(--gray-100); font-size: 0.875rem;
      outline: none; transition: border-color 0.15s, box-shadow 0.15s;
    }
    .search-input::placeholder { color: var(--gray-500); }
    .search-input:focus {
      border-color: var(--accent-blue);
      box-shadow: 0 0 0 1px var(--accent-blue);
    }
    .search-clear {
      position: absolute; right: 0.75rem; top: 50%; transform: translateY(-50%);
      background: none; border: none; cursor: pointer; color: var(--gray-400);
      display: flex; padding: 0;
    }
    .search-clear:hover { color: var(--gray-200); }
    .search-clear svg { width: 1rem; height: 1rem; }

    /* ===== Toolbar Row ===== */
    .toolbar {
      display: flex; align-items: center; justify-content: space-between;
      gap: 1rem; flex-wrap: wrap; margin-bottom: 1rem;
    }
    .toolbar-stats { font-size: 0.875rem; color: var(--gray-400); white-space: nowrap; }
    .toolbar-stats .stat-value { font-size: 1.125rem; font-weight: 600; }

    /* ===== Filter Pills ===== */
    .filter-pills { display: flex; flex-wrap: wrap; gap: 0.5rem; margin-bottom: 1rem; }
    .pill {
      padding: 0.25rem 0.75rem; border-radius: 9999px; font-size: 0.875rem;
      background: var(--dark-700); color: var(--gray-400); border: none;
      cursor: pointer; transition: color 0.15s, background 0.15s;
    }
    .pill:hover { color: var(--gray-200); background: var(--dark-600); }
    .pill.active { background: var(--accent-blue); color: #fff; }

    /* ===== Card / Panel ===== */
    .panel { background: var(--dark-800); border-radius: 0.5rem; overflow: hidden; }

    .btn {
      padding: 0.5rem 1rem; border-radius: 0.375rem; font-size: 0.875rem; font-weight: 500;
      border: 1px solid var(--dark-600); background: var(--dark-700); color: var(--gray-200);
      cursor: pointer; transition: background 0.15s, border-color 0.15s;
    }
    .btn:hover { background: var(--dark-600); border-color: var(--gray-500); }
    .btn-primary { background: var(--accent-blue); border-color: var(--accent-blue); color: #fff; }
    .btn-primary:hover { background: #4f6ae8; border-color: #4f6ae8; }

    .json-editor-panel { padding: 0; min-height: 24rem; }
    .json-editor-textarea {
      width: 100%; min-height: 24rem; padding: 1rem; box-sizing: border-box;
      font-family: 'SF Mono', 'Cascadia Code', 'Consolas', monospace; font-size: 0.8125rem;
      line-height: 1.4; color: var(--gray-200); background: var(--dark-900);
      border: none; resize: vertical; outline: none;
    }
    .json-editor-textarea::placeholder { color: var(--gray-600); }
    .json-editor-loading { padding: 2rem; text-align: center; color: var(--gray-500); }

    /* ===== Category (Buildings) ===== */
    .space-y > * + * { margin-top: 0.75rem; }

    .cat-header {
      width: 100%; padding: 0.75rem 1rem;
      display: flex; align-items: center; justify-content: space-between;
      background: none; border: none; cursor: pointer; color: inherit;
      transition: background 0.15s;
    }
    .cat-header:hover { background: var(--dark-700); }
    .cat-header-left { display: flex; align-items: center; gap: 0.75rem; }
    .cat-header svg {
      width: 1rem; height: 1rem; color: var(--gray-400);
      transition: transform 0.2s;
    }
    .cat-header svg.open { transform: rotate(90deg); }
    .cat-name { font-weight: 600; color: var(--accent-blue); }
    .cat-stats { font-size: 0.875rem; color: var(--gray-400); }
    .cat-stats .cat-placed { color: var(--gray-200); }

    /* ===== Tables ===== */
    table { width: 100%; border-collapse: collapse; }
    thead tr { border-bottom: 1px solid var(--dark-600); }
    th {
      padding: 0.75rem 1rem; font-size: 0.875rem; font-weight: 500;
      color: var(--gray-400); cursor: pointer; user-select: none;
      transition: color 0.15s;
    }
    th:hover { color: var(--gray-200); }
    th.left { text-align: left; }
    th.right { text-align: right; }
    .sort-icon { margin-left: 0.25rem; }
    .sort-icon.inactive { color: var(--gray-600); }
    .sort-icon.active { color: var(--accent-blue); }

    tbody tr { transition: background 0.15s; }
    tbody tr:hover { background: rgba(26, 26, 62, 0.5); }
    td { padding: 0.625rem 1rem; }
    td.left { text-align: left; }
    td.right { text-align: right; }
    td.mono { font-family: 'SF Mono', 'Cascadia Code', 'Consolas', monospace; }
    td.indent { padding-left: 2.75rem; }

    .cat-body { border-top: 1px solid var(--dark-600); }
    tbody.divide tr + tr { border-top: 1px solid var(--dark-700); }

    .empty-msg {
      padding: 2rem 1rem; text-align: center; color: var(--gray-500);
    }

    /* ===== Item/Building Icons ===== */
    .item-icon, .building-icon {
      width: 24px; height: 24px; vertical-align: middle;
      margin-right: 0.5rem; border-radius: 4px;
      image-rendering: pixelated;
      flex-shrink: 0;
    }
    .item-icon.small, .building-icon.small {
      width: 20px; height: 20px; margin-right: 0.375rem;
    }
    .name-with-icon {
      display: inline-flex; align-items: center;
    }
    .pill .building-icon {
      width: 18px; height: 18px; margin-right: 0.375rem; vertical-align: -3px;
    }

    /* ===== Map Tab ===== */
    .map-layout {
      display: flex; gap: 1rem; flex-wrap: wrap;
      align-items: stretch;
      min-height: calc(100vh - 11rem);
      height: calc(100vh - 11rem);
    }
    .map-wrapper {
      flex: 1; min-width: 300px; min-height: 0;
      display: flex; flex-direction: column;
      background: var(--dark-800); border-radius: 0.5rem;
      overflow: hidden; position: relative;
      border: 1px solid var(--dark-600);
    }
    .map-container {
      flex: 1; width: 100%; min-height: 0;
      cursor: grab; touch-action: none;
    }
    .map-container:active { cursor: grabbing; }
    .map-container svg {
      display: block; width: 100%; height: 100%; min-height: 300px;
    }
    .map-legend {
      width: 220px; flex-shrink: 0;
      background: var(--dark-800); border-radius: 0.5rem;
      padding: 0.75rem; border: 1px solid var(--dark-600);
      max-height: calc(100vh - 11rem); overflow-y: auto;
    }
    .map-legend-header {
      display: flex; align-items: center; flex-wrap: wrap; gap: 0.5rem;
      margin-bottom: 0.5rem; padding-bottom: 0.25rem; border-bottom: 1px solid var(--dark-600);
    }
    .map-legend h3 {
      font-size: 0.875rem; font-weight: 600; color: var(--gray-300);
      margin: 0; flex: 1;
    }
    .map-legend-toggle {
      padding: 0.2rem 0.5rem; font-size: 0.7rem;
      background: var(--dark-600); color: var(--gray-300);
      border: 1px solid var(--dark-500); border-radius: 0.25rem;
      cursor: pointer;
    }
    .map-legend-toggle:hover { background: var(--dark-500); color: var(--gray-100); }
    .map-legend-cat {
      margin-bottom: 0.75rem;
    }
    .map-legend-cat-collapsible .map-legend-cat-head {
      display: flex;
      align-items: center;
      gap: 0.25rem;
    }
    .map-legend-cat-chevron {
      flex-shrink: 0;
      width: 1rem;
      height: 1rem;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      color: var(--gray-500);
      transition: transform 0.15s ease;
    }
    .map-legend-cat-chevron:hover { color: var(--gray-300); }
    .map-legend-cat-collapsible.collapsed .map-legend-cat-chevron { transform: rotate(-90deg); }
    .map-legend-cat-collapsible.collapsed .map-legend-cat-body { display: none; }
    .map-legend-cat-title {
      font-size: 0.75rem; font-weight: 600; color: var(--accent-blue);
      margin-bottom: 0.25rem;
    }
    .map-legend-cat-toggle {
      display: flex; align-items: center; gap: 0.5rem;
      cursor: pointer; padding: 0.125rem 0;
    }
    .map-legend-cat-toggle input[type="checkbox"] {
      flex-shrink: 0; cursor: pointer; accent-color: var(--accent-blue);
    }
    .map-legend-item {
      display: flex; align-items: center; gap: 0.5rem;
      font-size: 0.75rem; color: var(--gray-400);
      padding: 0.125rem 0;
    }
    .map-legend-item-toggle {
      cursor: pointer;
    }
    .map-legend-item-toggle input[type="checkbox"] {
      flex-shrink: 0; cursor: pointer; accent-color: var(--accent-blue);
    }
    .map-legend-dot {
      width: 10px; height: 10px; border-radius: 50%;
      flex-shrink: 0;
    }
    .map-legend-item .map-legend-count { color: var(--gray-500); margin-left: auto; }
    .map-toolbar {
      display: flex; gap: 0.5rem; padding: 0.5rem;
      background: var(--dark-800); border-bottom: 1px solid var(--dark-600);
    }
    .map-toolbar button {
      padding: 0.375rem 0.75rem; font-size: 0.75rem;
      background: var(--dark-700); color: var(--gray-300);
      border: 1px solid var(--dark-600); border-radius: 0.25rem;
      cursor: pointer;
    }
    .map-toolbar button:hover { background: var(--dark-600); color: var(--gray-100); }
    .map-view-radio {
      display: flex; align-items: center; gap: 0.75rem; margin-left: 0.5rem;
    }
    .map-view-radio input[type="radio"] { accent-color: var(--accent-blue); cursor: pointer; }
    .map-view-radio label { font-size: 0.8rem; color: var(--gray-400); cursor: pointer; }
    .map-production-by-area { overflow-y: auto; max-height: 70vh; }
    .map-production-search-wrap { padding: 0 0.5rem 0.5rem; }
    .map-production-search {
      width: 100%; box-sizing: border-box; padding: 0.35rem 0.5rem; font-size: 0.8rem;
      background: var(--dark-700); border: 1px solid var(--dark-600); border-radius: 0.25rem;
      color: var(--gray-200);
    }
    .map-production-search::placeholder { color: var(--gray-500); }
    .map-production-search:focus { outline: none; border-color: var(--accent-blue); }
    .map-production-area-section {
      margin-bottom: 1rem; padding-bottom: 0.75rem; border-bottom: 1px solid var(--dark-600);
    }
    .map-production-area-section:last-child { border-bottom: none; }
    .map-production-area-toggle {
      display: flex; align-items: center; gap: 0.5rem; cursor: pointer; margin-bottom: 0.2rem;
    }
    .map-production-area-toggle input[type="checkbox"] { flex-shrink: 0; cursor: pointer; accent-color: var(--accent-blue); }
    .map-production-area-section.area-disabled .map-production-area-body { display: none; }
    .map-production-area-section.area-disabled .map-production-area-title { color: var(--gray-500); }
    .map-production-area-section.area-highlighted {
      background: rgba(34,197,94,0.15); border-left: 3px solid #22c55e; margin-left: -2px; padding-left: 0.25rem;
    }
    .map-production-area-title { font-size: 0.8rem; font-weight: 600; color: var(--gray-300); }
    .map-production-area-body { margin-top: 0.15rem; }
    .map-production-area-total { font-size: 0.75rem; color: var(--green-400); margin-bottom: 0.35rem; }
    .map-production-area-table { width: 100%; font-size: 0.75rem; }
    .map-production-area-table th { text-align: left; color: var(--gray-500); font-weight: 500; padding: 0.2rem 0; }
    .map-production-area-table td { padding: 0.15rem 0; color: var(--gray-400); }
    .map-production-area-table .right { text-align: right; }
    .map-production-area-table .rate-deficit { color: var(--red-400, #f87171); }
    .map-hover-label {
      position: absolute; pointer-events: none;
      padding: 0.35rem 0.6rem; border-radius: 0.25rem;
      background: var(--dark-700); border: 1px solid var(--dark-500);
      color: var(--gray-100); font-size: 0.8125rem; font-weight: 500;
      white-space: nowrap; box-shadow: 0 4px 12px rgba(0,0,0,0.4);
      z-index: 10; opacity: 0; transition: opacity 0.1s;
    }
    .map-hover-label.visible { opacity: 1; }
    .map-hover-label-cat { font-size: 0.6875rem; color: var(--gray-400); font-weight: 400; margin-top: 0.125rem; }
    .map-hover-label-produces { font-size: 0.6875rem; color: var(--accent-green); font-weight: 500; margin-top: 0.25rem; }

    /* ===== Utilities ===== */
    .hidden { display: none !important; }
  </style>
</head>
<body>
<script type="application/json" id="default-building-entities" data-encoding="base64-deflate">
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
</script>

<div class="app" id="app">
  <!-- Header -->
  <header>
    <div class="header-inner">
      <div class="header-left">
        <div class="logo"><span class="logo-accent">Rupture</span> Production</div>
        <span class="active-save-label hidden" id="activeSaveLabel"></span>
      </div>
    </div>
    <div class="tabs-container hidden" id="tabsContainer">
      <nav class="tabs-nav" id="tabsNav"></nav>
    </div>
  </header>

  <!-- Loading -->
  <div class="loading-overlay hidden" id="loadingOverlay">
    <div class="loading-card">
      <div class="spinner"></div>
      <div style="color: var(--gray-300)">Parsing save file...</div>
      <div style="color: var(--gray-500); font-size: 0.875rem">This may take a moment for large saves</div>
    </div>
  </div>

  <!-- Main -->
  <main id="mainContent"></main>

  <!-- Footer -->
  <footer>Rupture Production &mdash; Star Rupture Save Analyzer</footer>
</div>

<script>
// ===== Embedded Items Data =====
const ITEMS_DATA = {
  "Buildings": [
    { "InternalName": "/Game/Chimera/Buildings/MechanicalDrill/DA_MechanicalDrill.DA_MechanicalDrill", "Name": "Ore Extractor", "Category": "Extraction" },
    { "InternalName": "/Game/Chimera/Buildings/AcidExtractor/DA_AcidExtractor.DA_AcidExtractor", "Name": "Sulfur Extractor", "Category": "Extraction" },
    { "InternalName": "/Game/Chimera/Buildings/GasExtractor/DA_GasExtractor.DA_GasExtractor", "Name": "Helium-3 Extractor", "Category": "Extraction" },
    { "InternalName": "/Game/Chimera/Buildings/Smelter/DA_Smelter.DA_Smelter", "Name": "Smelter", "Category": "Ore Processing" },
    { "InternalName": "/Game/Chimera/Buildings/Furnace/DA_Furnace.DA_Furnace", "Name": "Furnace", "Category": "Crafting" },
    { "InternalName": "/Game/Chimera/Buildings/Refinery/DA_Refinery.DA_Refinery", "Name": "Refinery", "Category": "Ore Processing" },
    { "InternalName": "/Game/Chimera/Buildings/Crafter/DA_Crafter.DA_Crafter", "Name": "Fabricator", "Category": "Crafting" },
    { "InternalName": "/Game/Chimera/Buildings/Assembler/DA_Assembler.DA_Assembler", "Name": "Assembler", "Category": "Crafting" },
    { "InternalName": "/Game/Chimera/Buildings/Hammer/DA_Hammer.DA_Hammer", "Name": "Mega Press", "Category": "Crafting" },
    { "InternalName": "/Game/Chimera/Buildings/Synthetizer/DA_Synthetizer.DA_Synthetizer", "Name": "Compounder", "Category": "Crafting" },
    { "InternalName": "/Game/Chimera/Buildings/BaseCore/DA_BaseCore.DA_BaseCore", "Name": "Base Core", "Category": "Base Core" },
    { "InternalName": "/Game/Chimera/Buildings/Hub/DA_Hub.DA_Hub", "Name": "Hub", "Category": "Base Core" },
    { "InternalName": "/Game/Chimera/Buildings/Antena/DA_Antena.DA_Antena", "Name": "Antenna", "Category": "Base Core" },
    { "InternalName": "/Game/Chimera/Buildings/Teleporter/DA_Teleporter.DA_Teleporter", "Name": "Teleporter", "Category": "Base Core" },
    { "InternalName": "/Game/Chimera/Buildings/Storage/DA_Storage.DA_Storage", "Name": "Storage Depot v.2", "IsStorage": true, "Category": "Storage and Transport" },
    { "InternalName": "/Game/Chimera/Buildings/Interiors/PersonalStorage/DA_PersonalStorage.DA_PersonalStorage", "Name": "Personal Storage", "IsStorage": true, "Category": "Storage and Transport" },
    { "InternalName": "/Game/Chimera/Buildings/Interiors/PersonalStorageBig/DA_PersonalStorageBig.DA_PersonalStorageBig", "Name": "Large Personal Storage", "IsStorage": true, "Category": "Storage and Transport" },
    { "InternalName": "/Game/Chimera/Buildings/Interiors/PersonalStorage/PersonalStorage_NonDeconstructible/DA_PersonalStorage_NonDeconstructible.DA_PersonalStorage_NonDeconstructible", "Name": "Personal Storage (Fixed)", "IsStorage": true, "Category": "Storage and Transport" },
    { "InternalName": "/Game/Chimera/Buildings/ResourceRedistributor/DA_ResourceRedistributor.DA_ResourceRedistributor", "Name": "Storage Depot v.1", "Category": "Storage and Transport" },
    { "InternalName": "/Game/Chimera/Buildings/MultiStorage/DA_MultiStorage.DA_MultiStorage", "Name": "Multistorage", "IsStorage": true, "Category": "Storage and Transport" },
    { "InternalName": "/Game/Chimera/Buildings/UniversalStorage/DA_UniversalStorage.DA_UniversalStorage", "Name": "Multistorage", "IsStorage": true, "Category": "Storage and Transport" },
    { "InternalName": "/Game/Chimera/Buildings/PackageStation/PackageSender/DA_PackageSender.DA_PackageSender", "Name": "Package Sender", "Category": "Storage and Transport" },
    { "InternalName": "/Game/Chimera/Buildings/PackageStation/PackageReceiver/DA_PackageReceiver.DA_PackageReceiver", "Name": "Package Receiver", "Category": "Storage and Transport" },
    { "InternalName": "/Game/Chimera/Buildings/DroneConnections/DroneRail/DA_DroneRailT1.DA_DroneRailT1", "Name": "Drone Rail T1", "Category": "Rails" },
    { "InternalName": "/Game/Chimera/Buildings/DroneConnections/DroneRail/DA_DroneRailT2.DA_DroneRailT2", "Name": "Drone Rail T2", "Category": "Rails" },
    { "InternalName": "/Game/Chimera/Buildings/DroneConnections/DroneRail/DA_DroneRailT3.DA_DroneRailT3", "Name": "Drone Rail T3", "Category": "Rails" },
    { "InternalName": "/Game/Chimera/Buildings/DroneConnections/DronePole/DroneRailSupport/DA_DroneRailSupport.DA_DroneRailSupport", "Name": "Drone Rail Support", "Category": "Rails" },
    { "InternalName": "/Game/Chimera/Buildings/DroneConnections/InvisibleConnection/DA_DroneInvisiblePole.DA_DroneInvisiblePole", "Name": "Drone Invisible Pole", "Category": "Rails" },
    { "InternalName": "/Game/Chimera/Drones/DA_RailDroneConfig.DA_RailDroneConfig", "Name": "Drone", "Category": "Rails" },
    { "InternalName": "/Game/Chimera/Buildings/DroneConnections/DroneJunction/DA_DroneJunction_4.DA_DroneJunction_4", "Name": "Drone Junction", "Category": "Junctions" },
    { "InternalName": "/Game/Chimera/Buildings/DroneConnections/DroneJunction/DA_DroneMerger_3To1.DA_DroneMerger_3To1", "Name": "Drone Merger (3-to-1)", "Category": "Junctions" },
    { "InternalName": "/Game/Chimera/Buildings/DroneConnections/DroneJunction/DA_DroneMerger_5To1.DA_DroneMerger_5To1", "Name": "Drone Merger (5-to-1)", "Category": "Junctions" },
    { "InternalName": "/Game/Chimera/Buildings/DroneConnections/DroneJunction/DA_DroneLane_3.DA_DroneLane_3", "Name": "Drone Lane", "Category": "Junctions" },
    { "InternalName": "/Game/Chimera/Buildings/SolarPowerGenerator/DA_SolarPowerGenerator.DA_SolarPowerGenerator", "Name": "Solar Power Generator T1", "Category": "Power" },
    { "InternalName": "/Game/Chimera/Buildings/SolarPowerGeneratorTier2/DA_SolarPowerGeneratorTier2.DA_SolarPowerGeneratorTier2", "Name": "Solar Power Generator T2", "Category": "Power" },
    { "InternalName": "/Game/Chimera/Buildings/WindPowerGenerator/DA_WindPowerGenerator.DA_WindPowerGenerator", "Name": "Wind Power Generator T1", "Category": "Power" },
    { "InternalName": "/Game/Chimera/Buildings/WindPowerGeneratorTier2/DA_WindPowerGeneratorTier2.DA_WindPowerGeneratorTier2", "Name": "Wind Power Generator T2", "Category": "Power" },
    { "InternalName": "/Game/Chimera/Buildings/Cooler/Passive/DA_CoolerPassive.DA_CoolerPassive", "Name": "Passive Cooler", "Category": "Cooling" },
    { "InternalName": "/Game/Chimera/Buildings/Cooler/Active/DA_CoolerActive.DA_CoolerActive", "Name": "Active Cooler", "Category": "Cooling" },
    { "InternalName": "/Game/Chimera/Buildings/Turret_Tier1/DA_TurretTier1.DA_TurretTier1", "Name": "Turret T1", "Category": "Defensive" },
    { "InternalName": "/Game/Chimera/Buildings/Turret_Tier2/DA_TurretTier2.DA_TurretTier2", "Name": "Turret T2", "Category": "Defensive" },
    { "InternalName": "/Game/Chimera/Buildings/Interiors/Armory/DA_Armory.DA_Armory", "Name": "Armory", "Category": "Defensive" },
    { "InternalName": "/Game/Chimera/Buildings/Modular/Habitats/HabitatSmall/DA_HabitatSmall.DA_HabitatSmall", "Name": "Habitat (Small)", "Category": "Habitats" },
    { "InternalName": "/Game/Chimera/Buildings/Modular/HabitatModules/Airlock/DA_Airlock.DA_Airlock", "Name": "Airlock", "Category": "Habitat Modules" },
    { "InternalName": "/Game/Chimera/Buildings/Modular/HabitatModules/Airlock/Airlock_NonDeconstructible/DA_Airlock_StartingHUB.DA_Airlock_StartingHUB", "Name": "Airlock (Starting Hub)", "Category": "Habitat Modules" },
    { "InternalName": "/Game/Chimera/Buildings/Modular/HabitatModules/Viewport/ViewportLeft/DA_ViewportLeft.DA_ViewportLeft", "Name": "Viewport (Left)", "Category": "Habitat Modules" },
    { "InternalName": "/Game/Chimera/Buildings/Modular/HabitatModules/Viewport/ViewportMiddle/DA_ViewportMiddle.DA_ViewportMiddle", "Name": "Viewport (Middle)", "Category": "Habitat Modules" },
    { "InternalName": "/Game/Chimera/Buildings/Modular/HabitatModules/Viewport/ViewportRight/DA_ViewportRight.DA_ViewportRight", "Name": "Viewport (Right)", "Category": "Habitat Modules" },
    { "InternalName": "/Game/Chimera/Buildings/Modular/HabitatModules/Viewport/ViewportSingle/DA_ViewportSingle.DA_ViewportSingle", "Name": "Viewport (Single)", "Category": "Habitat Modules" },
    { "InternalName": "/Game/Chimera/Buildings/Modular/HabitatModules/RoomBridges/VerticalBridge/DA_VerticalBridge.DA_VerticalBridge", "Name": "Vertical Bridge", "Category": "Habitat Modules" },
    { "InternalName": "/Game/Chimera/Buildings/Modular/HabitatModules/RoomBridges/HorizontalBridge/DA_HorizontalBridge.DA_HorizontalBridge", "Name": "Horizontal Bridge", "Category": "Habitat Modules" },
    { "InternalName": "/Game/Chimera/Buildings/Interiors/ItemPrinter/DA_ItemPrinter.DA_ItemPrinter", "Name": "Item Printer", "Category": "Progression" },
    { "InternalName": "/Game/Chimera/Buildings/Hub/StartingPrinter/DA_StartingItemPrinter.DA_StartingItemPrinter", "Name": "Item Printer (Starting)", "Category": "Progression" },
    { "InternalName": "/Game/Chimera/Buildings/Interiors/ResearchTerminal/DA_ResearchTerminal.DA_ResearchTerminal", "Name": "Research Terminal", "Category": "Progression" },
    { "InternalName": "/Game/Chimera/Buildings/Interiors/RecipeTable/DA_RecipeTable.DA_RecipeTable", "Name": "Recipe Table", "Category": "Progression" },
    { "InternalName": "/Game/Chimera/Buildings/Interiors/Analyzer/DA_Analyzer.DA_Analyzer", "Name": "Analyzer", "Category": "Progression" },
    { "InternalName": "/Game/Chimera/Buildings/Interiors/CloningBed/DA_CloningBed.DA_CloningBed", "Name": "Cloning Bed", "Category": "Progression" },
    { "InternalName": "/Game/Chimera/Buildings/Interiors/CloningBed/CloningBed_NonDeconstructible/DA_CloningBed_NonDeconstructible.DA_CloningBed_NonDeconstructible", "Name": "Cloning Bed (Fixed)", "Category": "Progression" },
    { "InternalName": "/Game/Chimera/Buildings/Interiors/CloningBed/CloningBed_Lander/DA_CloningBed_Lander.DA_CloningBed_Lander", "Name": "Cloning Bed (Lander)", "Category": "Progression" },
    { "InternalName": "/Game/Chimera/Buildings/Interiors/FoodProcessor/DA_FoodProcessor.DA_FoodProcessor", "Name": "Food Processor", "Category": "Progression" },
    { "InternalName": "/Game/Chimera/Buildings/Interiors/SuitWorkshop/DA_SuitWorkshop.DA_SuitWorkshop", "Name": "Suit Workshop", "Category": "Progression" },
    { "InternalName": "/Game/Chimera/Buildings/Modular/Foundations/FoundationStability/DA_Modular_BasePlatformStability.DA_Modular_BasePlatformStability", "Name": "Foundation Stability", "Category": "Modular Components" },
    { "InternalName": "/Game/Chimera/Buildings/Modular/Foundations/FoundationStability/DA_Modular_ConnectingPlatformStability.DA_Modular_ConnectingPlatformStability", "Name": "Connecting Platform Stability", "Category": "Modular Components" },
    { "InternalName": "/Game/Chimera/Buildings/Modular/Tiles/BasePlatform/DA_Modular_BasePlatform.DA_Modular_BasePlatform", "Name": "Base Platform", "Category": "Modular Components" },
    { "InternalName": "/Game/Chimera/Buildings/Modular/Tiles/ConnectingPlatform/DA_Modular_ConnectingPlatform.DA_Modular_ConnectingPlatform", "Name": "Connecting Platform", "Category": "Modular Components" },
    { "InternalName": "/Game/Chimera/Buildings/Modular/PillarSupport/DA_Modular_PillarSupport.DA_Modular_PillarSupport", "Name": "Pillar Support", "Category": "Modular Components" },
    { "InternalName": "/Game/Chimera/Buildings/Modular/Tiles/Stairs/DA_Modular_Stairs.DA_Modular_Stairs", "Name": "Stairs", "Category": "Modular Components" },
    { "InternalName": "/Game/Chimera/Buildings/Modular/Tiles/Stairs/StairsFlat/DA_Modular_StairsFlat.DA_Modular_StairsFlat", "Name": "Stairs (Flat)", "Category": "Modular Components" },
    { "InternalName": "/Game/Chimera/Buildings/Modular/Walkway/DA_Walkway.DA_Walkway", "Name": "Walkway", "Category": "Modular Components" }
  ],
  "Items": [
    { "ItemName": "Basic Building Material", "InternalName": "/Game/Chimera/Crafting/CR_BasicBuildingMaterial.CR_BasicBuildingMaterial", "BuildingName": "Fabricator", "AmountProduced": 10, "Seconds": 2 },
    { "ItemName": "Intermediate Building Material", "InternalName": "/Game/Chimera/Crafting/CR_IntermediateBuildingMaterial.CR_IntermediateBuildingMaterial", "BuildingName": "Mega Press", "AmountProduced": 25, "Seconds": 6 },
    { "ItemName": "Quartz Building Material", "InternalName": "/Game/Chimera/Crafting/CR_QuartzBuildingMaterial.CR_QuartzBuildingMaterial", "BuildingName": "Fabricator", "AmountProduced": 1, "Seconds": 0 },
    { "ItemName": "Ignitium", "InternalName": "/Game/Chimera/Items/I_FireWaveOre.I_FireWaveOre", "BuildingName": "Found", "AmountProduced": 1, "Seconds": 0 },
    { "ItemName": "Meteorite Heart", "InternalName": "/Game/Chimera/Items/I_MeteorCore.I_MeteorCore", "BuildingName": "Found", "AmountProduced": 1, "Seconds": 0 },
    { "ItemName": "Heavy Ammo", "InternalName": "/Game/Chimera/Weapons/AmmoTypes/I_HeavyAmmoItem.I_HeavyAmmoItem", "BuildingName": "Mega Press", "AmountProduced": 15, "Seconds": 6 },
    { "ItemName": "Pistol Ammo", "InternalName": "/Game/Chimera/Weapons/AmmoTypes/I_PistolAmmoItem.I_PistolAmmoItem", "BuildingName": "Fabricator", "AmountProduced": 25, "Seconds": 4 },
    { "ItemName": "Shotgun Ammo", "InternalName": "/Game/Chimera/Weapons/AmmoTypes/I_ShotgunAmmo.I_ShotgunAmmo", "BuildingName": "Mega Press", "AmountProduced": 15, "Seconds": 6 },
    { "ItemName": "Standard Ammo", "InternalName": "/Game/Chimera/Weapons/AmmoTypes/I_StandardAmmoItem.I_StandardAmmoItem", "BuildingName": "Mega Press", "AmountProduced": 20, "Seconds": 6 },
    { "ItemName": "Calorie Fluid", "InternalName": "/Game/Chimera/Items/I_CalorieFluid.I_CalorieFluid", "BuildingName": "Food Processor", "AmountProduced": 1, "Seconds": 1 },
    { "ItemName": "Calorie Bar", "InternalName": "/Game/Chimera/Items/I_CalorieBar.I_CalorieBar", "BuildingName": "Food Processor", "AmountProduced": 1, "Seconds": 1 },
    { "ItemName": "Calorie Chew", "InternalName": "/Game/Chimera/Items/I_CalorieChew.I_CalorieChew", "BuildingName": "Food Processor", "AmountProduced": 1, "Seconds": 1 },
    { "ItemName": "Calorie Gel", "InternalName": "/Game/Chimera/Items/I_CalorieGel.I_CalorieGel", "BuildingName": "Food Processor", "AmountProduced": 1, "Seconds": 1 },
    { "ItemName": "Aqua Fluid", "InternalName": "/Game/Chimera/Items/I_AquaFluid.I_AquaFluid", "BuildingName": "Food Processor", "AmountProduced": 1, "Seconds": 1 },
    { "ItemName": "Aqua Bar", "InternalName": "/Game/Chimera/Items/I_AquaBar.I_AquaBar", "BuildingName": "Food Processor", "AmountProduced": 1, "Seconds": 1 },
    { "ItemName": "Nutri Gel", "InternalName": "/Game/Chimera/Items/I_NutriGel.I_NutriGel", "BuildingName": "Food Processor", "AmountProduced": 1, "Seconds": 1 },
    { "ItemName": "Serpent Sticks", "InternalName": "/Game/Chimera/Items/I_SerpentSticks.I_SerpentSticks", "BuildingName": "Food Processor", "AmountProduced": 1, "Seconds": 1 },
    { "ItemName": "Star Bites", "InternalName": "/Game/Chimera/Items/I_StarBites.I_StarBites", "BuildingName": "Food Processor", "AmountProduced": 1, "Seconds": 1 }
  ],
  "ItemNames": {
    "I_BasicBuildingMaterial": "Basic Building Material", "I_IntermediateBuildingMaterial": "Intermediate Building Material",
    "I_QuartzBuildingMaterial": "Quartz Building Material", "I_Ignitium": "Ignitium", "I_FireWaveOre": "Ignitium",
    "I_MeteorCore": "Meteorite Heart",
    "I_HeavyAmmoItem": "Heavy Ammo", "I_PistolAmmoItem": "Pistol Ammo", "I_ShotgunAmmo": "Shotgun Ammo", "I_StandardAmmoItem": "Standard Ammo", "I_StandardAmmo": "Standard Ammo",
    "I_CalorieFluid": "Calorie Fluid", "I_CalorieBar": "Calorie Bar", "I_CalorieChew": "Calorie Chew", "I_CalorieGel": "Calorie Gel",
    "I_AquaFluid": "Aqua Fluid", "I_AquaBar": "Aqua Bar", "I_NutriGel": "Nutri Gel", "I_SerpentSticks": "Serpent Sticks", "I_StarBites": "Star Bites",
    "I_Polifruit": "Polifruit", "I_StarTears": "Star Tears", "I_Hydrobulb": "Hydrobulb", "I_SerpentRoots": "Serpent Roots",
    "I_PrismHerb": "Prism Herb", "I_Grubbler": "Grubbler", "I_Prickler": "Pricklers"
  }
};

// Recipe inputs: food station only (output -> ingredients per 1 craft). Used for inventory/refund; RECIPE_INPUTS_FOR_ANALYSIS used for shortfalls.
const RECIPE_INPUTS = {
  "Calorie Fluid": [ { itemName: "Polifruit", amount: 30 }, { itemName: "Star Tears", amount: 20 } ],
  "Calorie Bar": [ { itemName: "Polifruit", amount: 80 }, { itemName: "Serpent Roots", amount: 30 } ],
  "Calorie Chew": [ { itemName: "Polifruit", amount: 45 }, { itemName: "Prism Herb", amount: 20 } ],
  "Calorie Gel": [ { itemName: "Polifruit", amount: 60 }, { itemName: "Grubbler", amount: 25 } ],
  "Aqua Fluid": [ { itemName: "Hydrobulb", amount: 30 }, { itemName: "Star Tears", amount: 20 } ],
  "Aqua Bar": [ { itemName: "Hydrobulb", amount: 45 }, { itemName: "Serpent Roots", amount: 30 } ],
  "Nutri Gel": [ { itemName: "Pricklers", amount: 80 }, { itemName: "Grubbler", amount: 25 } ],
  "Serpent Sticks": [ { itemName: "Serpent Roots", amount: 40 } ],
  "Star Bites": [ { itemName: "Star Tears", amount: 30 } ]
};

// Full item list for Production and Shortfalls tabs only (buildings produce these; we need to resolve recipe path -> name and rate).
const ITEMS_FOR_ANALYSIS = (function() {
  const limited = ITEMS_DATA.Items;
  const extra = [
    { "ItemName": "Accumulator", "InternalName": "/Game/Chimera/Crafting/CR_Accumulator.CR_Accumulator", "BuildingName": "Assembler", "AmountProduced": 1, "Seconds": 6 },
    { "ItemName": "Applicator", "InternalName": "/Game/Chimera/Crafting/CR_Syringe.CR_Syringe", "BuildingName": "Fabricator", "AmountProduced": 1, "Seconds": 4 },
    { "ItemName": "Battery", "InternalName": "/Game/Chimera/Crafting/CR_Battery.CR_Battery", "BuildingName": "Mega Press", "AmountProduced": 1, "Seconds": 4 },
    { "ItemName": "Calcite Sheets", "InternalName": "/Game/Chimera/Crafting/CR_CalciteSheets.CR_CalciteSheets", "BuildingName": "Fabricator", "AmountProduced": 2, "Seconds": 2 },
    { "ItemName": "Calcium Block", "InternalName": "/Game/Chimera/Crafting/CR_CalciumBlock.CR_CalciumBlock", "BuildingName": "Smelter", "AmountProduced": 2, "Seconds": 2 },
    { "ItemName": "Calcium Ore (Impure)", "InternalName": "/Game/Chimera/Crafting/MechanicalDrill/CR_CalciumOreImpure_MechanicalDrill.CR_CalciumOreImpure_MechanicalDrill", "BuildingName": "Ore Extractor", "AmountProduced": 2, "Seconds": 2 },
    { "ItemName": "Calcium Ore (Pure)", "InternalName": "/Game/Chimera/Crafting/MechanicalDrill/CR_CalciumOreImpure_MechanicalDrill.CR_CalciumOrePure_MechanicalDrill", "BuildingName": "Ore Extractor", "AmountProduced": 8, "Seconds": 2 },
    { "ItemName": "Calcium Ore", "InternalName": "/Game/Chimera/Crafting/MechanicalDrill/CR_CalciumOre_MechanicalDrill.CR_CalciumOre_MechanicalDrill", "BuildingName": "Ore Extractor", "AmountProduced": 4, "Seconds": 2 },
    { "ItemName": "Calcium Powder", "InternalName": "/Game/Chimera/Crafting/CR_CalciumPowder.CR_CalciumPowder", "BuildingName": "Furnace", "AmountProduced": 3, "Seconds": 3 },
    { "ItemName": "Ceramics", "InternalName": "/Game/Chimera/Crafting/CR_Ceramics.CR_Ceramics", "BuildingName": "Furnace", "AmountProduced": 2, "Seconds": 2 },
    { "ItemName": "Chemicals", "InternalName": "/Game/Chimera/Crafting/CR_Explosive.CR_Explosive", "BuildingName": "Furnace", "AmountProduced": 2, "Seconds": 2 },
    { "ItemName": "Condenser", "InternalName": "/Game/Chimera/Crafting/CR_Condenser.CR_Condenser", "BuildingName": "Assembler", "AmountProduced": 1, "Seconds": 15 },
    { "ItemName": "Electromagnet", "InternalName": "/Game/Chimera/Crafting/CR_Electromagnet.CR_Electromagnet", "BuildingName": "Assembler", "AmountProduced": 1, "Seconds": 5 },
    { "ItemName": "Electromagnetic Coil", "InternalName": "/Game/Chimera/Crafting/CR_ElectromagneticCoil.CR_ElectromagneticCoil", "BuildingName": "Mega Press", "AmountProduced": 1, "Seconds": 4 },
    { "ItemName": "Electronics", "InternalName": "/Game/Chimera/Crafting/CR_Electronics.CR_Electronics", "BuildingName": "Furnace", "AmountProduced": 1, "Seconds": 5 },
    { "ItemName": "Generator", "InternalName": "/Game/Chimera/Crafting/CR_Generator.CR_Generator", "BuildingName": "Assembler", "AmountProduced": 1, "Seconds": 10 },
    { "ItemName": "Glass", "InternalName": "/Game/Chimera/Crafting/CR_Glass.CR_Glass", "BuildingName": "Furnace", "AmountProduced": 1, "Seconds": 3 },
    { "ItemName": "Hardening Agent", "InternalName": "/Game/Chimera/Crafting/CR_HardeningAgent.CR_HardeningAgent", "BuildingName": "Furnace", "AmountProduced": 2, "Seconds": 4 },
    { "ItemName": "Heat Resistant Sheet", "InternalName": "/Game/Chimera/Crafting/CR_HeatResistantSheet.CR_HeatResistantSheet", "BuildingName": "Furnace", "AmountProduced": 1, "Seconds": 4 },
    { "ItemName": "Helium-3", "InternalName": "/Game/Chimera/Crafting/CR_Helium.CR_Helium", "BuildingName": "Helium-3 Extractor", "AmountProduced": 8, "Seconds": 2 },
    { "ItemName": "Impeller", "InternalName": "/Game/Chimera/Crafting/CR_Impeller.CR_Impeller", "BuildingName": "Mega Press", "AmountProduced": 1, "Seconds": 4 },
    { "ItemName": "Inductor", "InternalName": "/Game/Chimera/Crafting/CR_Coil.CR_Coil", "BuildingName": "Furnace", "AmountProduced": 1, "Seconds": 3 },
    { "ItemName": "Ion Injector", "InternalName": "/Game/Chimera/Crafting/CR_IonInjector.CR_IonInjector", "BuildingName": "Compounder", "AmountProduced": 1, "Seconds": 12 },
    { "ItemName": "Laser Emitter", "InternalName": "/Game/Chimera/Crafting/CR_LaserEmitter.CR_LaserEmitter", "BuildingName": "Assembler", "AmountProduced": 1, "Seconds": 6 },
    { "ItemName": "Lens", "InternalName": "/Game/Chimera/Crafting/CR_Lens.CR_Lens", "BuildingName": "Compounder", "AmountProduced": 1, "Seconds": 12 },
    { "ItemName": "Liquid Helium", "InternalName": "/Game/Chimera/Crafting/CR_LiquidHelium.CR_LiquidHelium", "BuildingName": "Compounder", "AmountProduced": 1, "Seconds": 3 },
    { "ItemName": "Nanofiber", "InternalName": "/Game/Chimera/Crafting/CR_Nanofibre.CR_Nanofibre", "BuildingName": "Compounder", "AmountProduced": 1, "Seconds": 5 },
    { "ItemName": "Nozzle", "InternalName": "/Game/Chimera/Crafting/CR_Nozzle.CR_Nozzle", "BuildingName": "Mega Press", "AmountProduced": 1, "Seconds": 5 },
    { "ItemName": "Pressure Tank", "InternalName": "/Game/Chimera/Crafting/CR_PressureTank.CR_PressureTank", "BuildingName": "Assembler", "AmountProduced": 1, "Seconds": 12 },
    { "ItemName": "Pressurized Helium", "InternalName": "/Game/Chimera/Crafting/CR_PressurizedHelium.CR_PressurizedHelium", "BuildingName": "Refinery", "AmountProduced": 1, "Seconds": 2 },
    { "ItemName": "Pump", "InternalName": "/Game/Chimera/Crafting/CR_Pump.CR_Pump", "BuildingName": "Mega Press", "AmountProduced": 1, "Seconds": 10 },
    { "ItemName": "Resonator", "InternalName": "/Game/Chimera/Crafting/CR_Resonator.CR_Resonator", "BuildingName": "Assembler", "AmountProduced": 1, "Seconds": 12 },
    { "ItemName": "Rotor", "InternalName": "/Game/Chimera/Crafting/CR_Rotor.CR_Rotor", "BuildingName": "Fabricator", "AmountProduced": 1, "Seconds": 6 },
    { "ItemName": "Scanner", "InternalName": "/Game/Chimera/Crafting/CR_Scanner.CR_Scanner", "BuildingName": "Assembler", "AmountProduced": 1, "Seconds": 10 },
    { "ItemName": "Stabilizer", "InternalName": "/Game/Chimera/Crafting/CR_Gyroscope.CR_Gyroscope", "BuildingName": "Fabricator", "AmountProduced": 1, "Seconds": 6 },
    { "ItemName": "Stator", "InternalName": "/Game/Chimera/Crafting/CR_Stator.CR_Stator", "BuildingName": "Fabricator", "AmountProduced": 1, "Seconds": 3 },
    { "ItemName": "Sulfur Ore", "InternalName": "/Game/Chimera/Crafting/CR_SulphurOre.CR_SulphurOre", "BuildingName": "Sulfur Extractor", "AmountProduced": 8, "Seconds": 2 },
    { "ItemName": "Sulfuric Acid", "InternalName": "/Game/Chimera/Crafting/CR_SulphuricAcid.CR_SulphuricAcid", "BuildingName": "Refinery", "AmountProduced": 1, "Seconds": 0.5 },
    { "ItemName": "Superconductor", "InternalName": "/Game/Chimera/Crafting/CR_Superconductor.CR_Superconductor", "BuildingName": "Compounder", "AmountProduced": 1, "Seconds": 5 },
    { "ItemName": "Supermagnet", "InternalName": "/Game/Chimera/Crafting/CR_Supermagnet.CR_Supermagnet", "BuildingName": "Furnace", "AmountProduced": 1, "Seconds": 3 },
    { "ItemName": "Synthetic Resin", "InternalName": "/Game/Chimera/Crafting/CR_SyntheticResin.CR_SyntheticResin", "BuildingName": "Compounder", "AmountProduced": 1, "Seconds": 3 },
    { "ItemName": "Synthetic Silicon", "InternalName": "/Game/Chimera/Crafting/CR_SilicaSand.CR_SilicaSand", "BuildingName": "Furnace", "AmountProduced": 2, "Seconds": 2 },
    { "ItemName": "Titanium Bar", "InternalName": "/Game/Chimera/Crafting/CR_TitaniumBar.CR_TitaniumBar", "BuildingName": "Smelter", "AmountProduced": 2, "Seconds": 2 },
    { "ItemName": "Titanium Beam", "InternalName": "/Game/Chimera/Crafting/CR_TitaniumBeam.CR_TitaniumBeam", "BuildingName": "Fabricator", "AmountProduced": 1, "Seconds": 3 },
    { "ItemName": "Titanium Housing", "InternalName": "/Game/Chimera/Crafting/CR_TitaniumHousing.CR_TitaniumHousing", "BuildingName": "Furnace", "AmountProduced": 1, "Seconds": 2 },
    { "ItemName": "Titanium Ore (Impure)", "InternalName": "/Game/Chimera/Crafting/MechanicalDrill/CR_TitaniumOreImpure_MechanicalDrill.CR_TitaniumOreImpure_MechanicalDrill", "BuildingName": "Ore Extractor", "AmountProduced": 2, "Seconds": 2 },
    { "ItemName": "Titanium Ore (Pure)", "InternalName": "/Game/Chimera/Crafting/MechanicalDrill/CR_TitaniumOrePure_MechanicalDrill.CR_TitaniumOrePure_MechanicalDrill", "BuildingName": "Ore Extractor", "AmountProduced": 8, "Seconds": 2 },
    { "ItemName": "Titanium Ore", "InternalName": "/Game/Chimera/Crafting/MechanicalDrill/CR_TitaniumOre_MechanicalDrill.CR_TitaniumOre_MechanicalDrill", "BuildingName": "Ore Extractor", "AmountProduced": 4, "Seconds": 2 },
    { "ItemName": "Titanium Rod", "InternalName": "/Game/Chimera/Crafting/CR_TitaniumRod.CR_TitaniumRod", "BuildingName": "Fabricator", "AmountProduced": 1, "Seconds": 2 },
    { "ItemName": "Titanium Sheet", "InternalName": "/Game/Chimera/Crafting/CR_TitaniumSheet.CR_TitaniumSheet", "BuildingName": "Fabricator", "AmountProduced": 2, "Seconds": 2 },
    { "ItemName": "Tube", "InternalName": "/Game/Chimera/Crafting/CR_Tube.CR_Tube", "BuildingName": "Fabricator", "AmountProduced": 2, "Seconds": 2 },
    { "ItemName": "Turbine", "InternalName": "/Game/Chimera/Crafting/CR_Turbine.CR_Turbine", "BuildingName": "Mega Press", "AmountProduced": 1, "Seconds": 6 },
    { "ItemName": "Valve", "InternalName": "/Game/Chimera/Crafting/CR_Valve.CR_Valve", "BuildingName": "Mega Press", "AmountProduced": 1, "Seconds": 10 },
    { "ItemName": "Wolfram Bar", "InternalName": "/Game/Chimera/Crafting/CR_WolframBar.CR_WolframBar", "BuildingName": "Smelter", "AmountProduced": 2, "Seconds": 2 },
    { "ItemName": "Wolfram Ore (Impure)", "InternalName": "/Game/Chimera/Crafting/MechanicalDrill/CR_WolframOreImpure_MechanicalDrill.CR_WolframOreImpure_MechanicalDrill", "BuildingName": "Ore Extractor", "AmountProduced": 2, "Seconds": 2 },
    { "ItemName": "Wolfram Ore (Pure)", "InternalName": "/Game/Chimera/Crafting/MechanicalDrill/CR_WolframOrePure_MechanicalDrill.CR_WolframOrePure_MechanicalDrill", "BuildingName": "Ore Extractor", "AmountProduced": 8, "Seconds": 2 },
    { "ItemName": "Wolfram Ore", "InternalName": "/Game/Chimera/Crafting/MechanicalDrill/CR_WolframOre_MechanicalDrill.CR_WolframOre_MechanicalDrill", "BuildingName": "Ore Extractor", "AmountProduced": 4, "Seconds": 2 },
    { "ItemName": "Wolfram Plate", "InternalName": "/Game/Chimera/Crafting/CR_WolframPlate.CR_WolframPlate", "BuildingName": "Fabricator", "AmountProduced": 1, "Seconds": 1 },
    { "ItemName": "Wolfram Powder", "InternalName": "/Game/Chimera/Crafting/CR_WolframPowder.CR_WolframPowder", "BuildingName": "Furnace", "AmountProduced": 3, "Seconds": 2 },
    { "ItemName": "Wolfram Wire", "InternalName": "/Game/Chimera/Crafting/CR_WolframWire.CR_WolframWire", "BuildingName": "Fabricator", "AmountProduced": 2, "Seconds": 4 }
  ];
  const seen = new Set(limited.map(i => i.InternalName));
  return [...limited, ...extra.filter(e => !seen.has(e.InternalName))];
})();

// Full recipe inputs for shortfall consumption (production tab). Merges RECIPE_INPUTS (food) with crafting recipes.
const RECIPE_INPUTS_FOR_ANALYSIS = Object.assign({
  "Accumulator": [ { itemName: "Calcium Ore", amount: 20 }, { itemName: "Helium-3", amount: 8 }, { itemName: "Sulfur Ore", amount: 4 }, { itemName: "Titanium Ore", amount: 44 }, { itemName: "Wolfram Ore", amount: 26 } ],
  "Battery": [ { itemName: "Calcium Ore", amount: 12 }, { itemName: "Helium-3", amount: 4 }, { itemName: "Sulfur Ore", amount: 2 }, { itemName: "Titanium Ore", amount: 16 }, { itemName: "Wolfram Ore", amount: 16 } ],
  "Calcium Block": [ { itemName: "Calcium Ore", amount: 2 } ],
  "Titanium Bar": [ { itemName: "Titanium Ore", amount: 2 } ],
  "Wolfram Bar": [ { itemName: "Wolfram Ore", amount: 2 } ],
  "Calcium Powder": [ { itemName: "Calcium Block", amount: 2 } ],
  "Calcite Sheets": [ { itemName: "Calcium Ore", amount: 2 } ],
  "Ceramics": [ { itemName: "Calcite Sheets", amount: 2 }, { itemName: "Wolfram Powder", amount: 1 } ],
  "Electromagnet": [ { itemName: "Electromagnetic Coil", amount: 1 }, { itemName: "Inductor", amount: 1 } ],
  "Electromagnetic Coil": [ { itemName: "Wolfram Wire", amount: 2 } ],
  "Electronics": [ { itemName: "Synthetic Silicon", amount: 2 }, { itemName: "Inductor", amount: 1 }, { itemName: "Stator", amount: 1 } ],
  "Glass": [ { itemName: "Helium-3", amount: 2 }, { itemName: "Calcium Powder", amount: 1 } ],
  "Inductor": [ { itemName: "Ceramics", amount: 1 }, { itemName: "Tube", amount: 1 }, { itemName: "Wolfram Wire", amount: 1 } ],
  "Liquid Helium": [ { itemName: "Helium-3", amount: 4 }, { itemName: "Pressurized Helium", amount: 1 } ],
  "Pressurized Helium": [ { itemName: "Helium-3", amount: 4 } ],
  "Rotor": [ { itemName: "Titanium Rod", amount: 2 }, { itemName: "Wolfram Wire", amount: 2 } ],
  "Stator": [ { itemName: "Titanium Housing", amount: 2 }, { itemName: "Wolfram Wire", amount: 2 } ],
  "Sulfuric Acid": [ { itemName: "Sulfur Ore", amount: 2 } ],
  "Superconductor": [ { itemName: "Wolfram Wire", amount: 2 }, { itemName: "Liquid Helium", amount: 1 } ],
  "Synthetic Resin": [ { itemName: "Chemicals", amount: 1 }, { itemName: "Synthetic Silicon", amount: 1 } ],
  "Synthetic Silicon": [ { itemName: "Ceramics", amount: 2 }, { itemName: "Calcium Powder", amount: 1 }, { itemName: "Helium-3", amount: 2 } ],
  "Titanium Beam": [ { itemName: "Titanium Bar", amount: 2 } ],
  "Titanium Housing": [ { itemName: "Titanium Sheet", amount: 2 }, { itemName: "Titanium Beam", amount: 1 } ],
  "Titanium Rod": [ { itemName: "Titanium Bar", amount: 1 } ],
  "Titanium Sheet": [ { itemName: "Titanium Bar", amount: 2 } ],
  "Tube": [ { itemName: "Titanium Sheet", amount: 2 }, { itemName: "Titanium Rod", amount: 1 } ],
  "Wolfram Plate": [ { itemName: "Wolfram Bar", amount: 2 } ],
  "Wolfram Powder": [ { itemName: "Wolfram Ore", amount: 2 } ],
  "Wolfram Wire": [ { itemName: "Wolfram Bar", amount: 1 } ],
  "Chemicals": [ { itemName: "Synthetic Silicon", amount: 2 }, { itemName: "Wolfram Powder", amount: 1 }, { itemName: "Helium-3", amount: 2 } ],
  "Heat Resistant Sheet": [ { itemName: "Wolfram Plate", amount: 1 }, { itemName: "Titanium Sheet", amount: 1 }, { itemName: "Glass", amount: 1 } ],
  "Nanofiber": [ { itemName: "Synthetic Resin", amount: 1 }, { itemName: "Chemicals", amount: 1 } ],
  "Nozzle": [ { itemName: "Titanium Housing", amount: 1 }, { itemName: "Tube", amount: 1 } ],
  "Pump": [ { itemName: "Titanium Housing", amount: 1 }, { itemName: "Rotor", amount: 1 }, { itemName: "Nozzle", amount: 1 } ],
  "Condenser": [ { itemName: "Pressure Tank", amount: 1 }, { itemName: "Pump", amount: 1 }, { itemName: "Liquid Helium", amount: 2 } ],
  "Generator": [ { itemName: "Electromagnet", amount: 2 }, { itemName: "Rotor", amount: 1 }, { itemName: "Stator", amount: 1 } ],
  "Resonator": [ { itemName: "Electromagnet", amount: 1 }, { itemName: "Electronics", amount: 1 } ],
  "Laser Emitter": [ { itemName: "Electronics", amount: 1 }, { itemName: "Lens", amount: 1 }, { itemName: "Resonator", amount: 1 } ],
  "Lens": [ { itemName: "Glass", amount: 2 }, { itemName: "Superconductor", amount: 1 } ],
  "Pressure Tank": [ { itemName: "Titanium Sheet", amount: 2 }, { itemName: "Tube", amount: 2 } ],
  "Turbine": [ { itemName: "Nozzle", amount: 1 }, { itemName: "Rotor", amount: 2 }, { itemName: "Stator", amount: 1 } ],
  "Valve": [ { itemName: "Titanium Housing", amount: 1 }, { itemName: "Tube", amount: 1 } ],
  "Stabilizer": [ { itemName: "Rotor", amount: 2 }, { itemName: "Titanium Rod", amount: 2 } ],
  "Scanner": [ { itemName: "Electronics", amount: 2 }, { itemName: "Lens", amount: 1 }, { itemName: "Resonator", amount: 1 } ],
  "Applicator": [ { itemName: "Tube", amount: 2 }, { itemName: "Glass", amount: 1 } ],
  "Basic Building Material": [ { itemName: "Titanium Ore", amount: 1 }, { itemName: "Wolfram Ore", amount: 1 } ],
  "Intermediate Building Material": [ { itemName: "Basic Building Material", amount: 10 }, { itemName: "Glass", amount: 2 }, { itemName: "Inductor", amount: 2 } ]
}, RECIPE_INPUTS);

// For slot-limited inventory: which items count as "food" vs "crafted" (for priority order).
const FOOD_ITEM_NAMES = new Set([
  'Calorie Fluid', 'Calorie Bar', 'Calorie Chew', 'Calorie Gel', 'Aqua Fluid', 'Aqua Bar', 'Nutri Gel', 'Serpent Sticks', 'Star Bites',
  'Polifruit', 'Star Tears', 'Hydrobulb', 'Serpent Roots', 'Prism Herb', 'Grubbler', 'Pricklers'
]);
const CRAFTED_ITEM_NAMES = new Set([
  'Basic Building Material', 'Intermediate Building Material', 'Quartz Building Material', 'Ignitium', 'Meteorite Heart',
  'Heavy Ammo', 'Pistol Ammo', 'Shotgun Ammo', 'Standard Ammo'
]);
/** User choice when inventory has more stacks than slots: 'foodFirst' | 'craftedFirst'. */
let inventoryPriority = 'foodFirst';

const CATEGORY_ORDER = [
  'Extraction', 'Ore Processing', 'Crafting', 'Base Core', 'Storage and Transport',
  'Rails', 'Junctions', 'Power', 'Cooling', 'Defensive', 'Habitats',
  'Habitat Modules', 'Progression', 'Modular Components',
];

// Build cost per building (Name -> [{ itemName, amount }]). Used when refunding materials on remove.
// Buildings not listed use DEFAULT_BUILDING_COST (10 Basic Building Material).
const DEFAULT_BUILDING_COST = [ { itemName: 'Basic Building Material', amount: 10 } ];
const BUILDING_BUILD_COSTS = {
  'Base Core': [ { itemName: 'Basic Building Material', amount: 80 }, { itemName: 'Intermediate Building Material', amount: 20 } ],
  'Ore Extractor': [ { itemName: 'Basic Building Material', amount: 10 } ],
  'Sulfur Extractor': [ { itemName: 'Basic Building Material', amount: 10 } ],
  'Helium-3 Extractor': [ { itemName: 'Basic Building Material', amount: 15 }, { itemName: 'Intermediate Building Material', amount: 5 } ],
  'Smelter': [ { itemName: 'Basic Building Material', amount: 15 } ],
  'Furnace': [ { itemName: 'Basic Building Material', amount: 12 } ],
  'Refinery': [ { itemName: 'Basic Building Material', amount: 15 }, { itemName: 'Intermediate Building Material', amount: 5 } ],
  'Fabricator': [ { itemName: 'Basic Building Material', amount: 10 } ],
  'Assembler': [ { itemName: 'Intermediate Building Material', amount: 5 } ],
  'Mega Press': [ { itemName: 'Intermediate Building Material', amount: 8 } ],
  'Compounder': [ { itemName: 'Intermediate Building Material', amount: 10 } ],
  'Storage Depot v.2': [ { itemName: 'Basic Building Material', amount: 10 }, { itemName: 'Intermediate Building Material', amount: 5 }, { itemName: 'Quartz Building Material', amount: 5 } ],
  'Storage Depot v.1': [ { itemName: 'Basic Building Material', amount: 15 } ],
  'Personal Storage': [ { itemName: 'Basic Building Material', amount: 5 } ],
  'Large Personal Storage': [ { itemName: 'Basic Building Material', amount: 10 }, { itemName: 'Intermediate Building Material', amount: 5 } ],
  'Multistorage': [ { itemName: 'Intermediate Building Material', amount: 15 }, { itemName: 'Quartz Building Material', amount: 5 } ],
  'Teleporter': [ { itemName: 'Intermediate Building Material', amount: 25 }, { itemName: 'Quartz Building Material', amount: 15 } ],
  'Antenna': [ { itemName: 'Basic Building Material', amount: 20 }, { itemName: 'Intermediate Building Material', amount: 10 } ],
  'Hub': [ { itemName: 'Basic Building Material', amount: 50 }, { itemName: 'Intermediate Building Material', amount: 15 } ],
  'Solar Power Generator T1': [ { itemName: 'Basic Building Material', amount: 15 } ],
  'Solar Power Generator T2': [ { itemName: 'Intermediate Building Material', amount: 20 }, { itemName: 'Quartz Building Material', amount: 10 } ],
  'Wind Power Generator T1': [ { itemName: 'Basic Building Material', amount: 12 } ],
  'Wind Power Generator T2': [ { itemName: 'Intermediate Building Material', amount: 15 }, { itemName: 'Quartz Building Material', amount: 8 } ],
  'Drone Rail T1': [ { itemName: 'Basic Building Material', amount: 5 } ],
  'Drone Rail T2': [ { itemName: 'Basic Building Material', amount: 8 }, { itemName: 'Intermediate Building Material', amount: 2 } ],
  'Drone Rail T3': [ { itemName: 'Intermediate Building Material', amount: 5 } ],
  'Turret T1': [ { itemName: 'Basic Building Material', amount: 20 }, { itemName: 'Intermediate Building Material', amount: 5 } ],
  'Turret T2': [ { itemName: 'Intermediate Building Material', amount: 15 }, { itemName: 'Quartz Building Material', amount: 5 } ]
};
function getBuildingBuildCost(buildingName) {
  return BUILDING_BUILD_COSTS[buildingName] || DEFAULT_BUILDING_COST;
}

// Base Core upgrade Ignitium costs (level 12: 10, 23: 30, 34: 90, 45: 150). Cumulative refund for level 0..4.
const BASE_CORE_IGNITIUM_UPGRADE_COSTS = [ 10, 30, 90, 150 ];
const BASE_CORE_IGNITIUM_CUMULATIVE = [ 0, 10, 40, 130, 280 ];
function getBaseCoreIgnitiumRefundForLevel(level) {
  const L = Math.max(0, Math.min(4, Math.floor(Number(level) || 0)));
  return BASE_CORE_IGNITIUM_CUMULATIVE[L] || 0;
}
// Base Core Meteorite Heart: 1 to build, then 30/50/60/70 for upgrades to level 1/2/3/4. Cumulative for level 0..4.
const BASE_CORE_METEORITE_HEART_CUMULATIVE = [ 1, 31, 81, 141, 211 ];
function getBaseCoreMeteoriteHeartRefundForLevel(level) {
  const L = Math.max(0, Math.min(4, Math.floor(Number(level) || 0)));
  return BASE_CORE_METEORITE_HEART_CUMULATIVE[L] ?? 1;
}
function getBaseCoreLevelFromEntity(entityValue) {
  const frag = entityValue && entityValue.fragmentValues;
  if (!Array.isArray(frag)) return 0;
  for (const f of frag) {
    const s = String(f);
    if (!s.includes('BaseCore') && !s.includes('Base Core')) continue;
    const m = s.match(/UpgradeLevel=(\d+)/i) || s.match(/CapacityLevel=(\d+)/i) || s.match(/CurrentLevel=(\d+)/i) || s.match(/Level=(\d+)/);
    if (m) return parseInt(m[1], 10);
  }
  return 0;
}

/** Build map entityIdNum -> upgradeLevel from itemData.BaseCoreReplicationHelperSaveData.baseCoreSaveData. */
function getBaseCoreLevelMapFromSaveData(itemData) {
  const map = new Map();
  if (!itemData || typeof itemData !== 'object') return map;
  const helper = itemData.BaseCoreReplicationHelperSaveData;
  if (!helper || typeof helper !== 'object') return map;
  const arr = helper.baseCoreSaveData;
  if (!Array.isArray(arr)) return map;
  for (const entry of arr) {
    if (!entry || typeof entry !== 'object') continue;
    const baseCore = entry.baseCore ?? entry.BaseCore;
    if (!baseCore || typeof baseCore !== 'object') continue;
    const id = baseCore.iD ?? baseCore.ID;
    if (id == null) continue;
    const level = entry.upgradeLevel ?? entry.UpgradeLevel;
    if (level != null) map.set(Number(id), Math.max(0, Math.min(4, Math.floor(Number(level) || 0))));
  }
  return map;
}

// ===== Icon Mappings =====
const ICON_BASE = 'https://www.starrupture-planner.com/icons';

const ITEM_ICONS = {
  'Basic Building Material': 'basic_building', 'Intermediate Building Material': 'intermediate_building', 'Quartz Building Material': 'quartz_building',
  'Ignitium': 'ore_firewave', 'Meteorite Heart': 'meteor_core',
  'Heavy Ammo': 'heavy_ammo', 'Pistol Ammo': 'pistol_ammo', 'Shotgun Ammo': 'shotgun_ammo', 'Standard Ammo': 'standard_ammo',
  'Calorie Fluid': 'calorie_fluid', 'Calorie Bar': 'calorie_bar', 'Calorie Chew': 'calorie_chew', 'Calorie Gel': 'calorie_gel',
  'Aqua Fluid': 'aqua_fluid', 'Aqua Bar': 'aqua_bar', 'Nutri Gel': 'nutri_gel', 'Serpent Sticks': 'serpent_sticks', 'Star Bites': 'star_bites',
  'Polifruit': 'polifruit', 'Star Tears': 'star_tears', 'Hydrobulb': 'hydrobulb', 'Serpent Roots': 'serpent_roots',
  'Prism Herb': 'prism_herb', 'Grubbler': 'grubbler', 'Pricklers': 'pricklers',
};

const BUILDING_ICONS = {
  'Assembler': 'assembler', 'Compounder': 'compounder', 'Fabricator': 'fabricator',
  'Furnace': 'furnace', 'Helium-3 Extractor': 'helium_extractor', 'Mega Press': 'mega_press',
  'Ore Extractor': 'ore_excavator', 'Refinery': 'refinery', 'Smelter': 'smelter',
  'Sulfur Extractor': 'sulfur_extractor', 'Base Core': 'base_core',
  'Storage Depot v.1': 'storage_depot_v1', 'Storage Depot v.2': 'storage_depot_v1', 'Multistorage': 'storage_depot_v1', 'Habitat (Small)': 'habitat',
  'Solar Power Generator T1': 'solar_generator_v1', 'Solar Power Generator T2': 'solar_generator_v2',
  'Wind Power Generator T1': 'wind_turbine_v1', 'Wind Power Generator T2': 'wind_turbine_v2',
  'Turret T1': 'turret_v1', 'Turret T2': 'turret_v2',
  'Package Sender': 'package_dispatcher', 'Package Receiver': 'package_receiver',
  'Drone Merger (3-to-1)': 'drone_merger_3_to_1',
};

function itemIconHTML(name, cssClass) {
  const icon = ITEM_ICONS[name];
  if (!icon) return '';
  const cls = cssClass ? `item-icon ${cssClass}` : 'item-icon';
  return `<img class="${cls}" src="${ICON_BASE}/items/${icon}.png" alt="" loading="lazy" onerror="this.style.display='none'">`;
}

function buildingIconHTML(name, cssClass) {
  const icon = BUILDING_ICONS[name];
  if (!icon) return '';
  const cls = cssClass ? `building-icon ${cssClass}` : 'building-icon';
  return `<img class="${cls}" src="${ICON_BASE}/buildings/${icon}.png" alt="" loading="lazy" onerror="this.style.display='none'">`;
}

const BUILDING_COLOR_OVERRIDES = {
  'Assembler': 'hsl(210, 65%, 55%)',
  'Compounder': 'hsl(280, 65%, 55%)',
  'Fabricator': 'hsl(35, 65%, 55%)'
};

function hashColor(name) {
  if (BUILDING_COLOR_OVERRIDES[name]) return BUILDING_COLOR_OVERRIDES[name];
  let h = 0;
  for (let i = 0; i < name.length; i++) h = ((h << 5) - h) + name.charCodeAt(i) | 0;
  const hue = Math.abs(h % 360);
  const sat = 65;
  const light = 55;
  return `hsl(${hue}, ${sat}%, ${light}%)`;
}

// ===== State =====
let analysisData = null;
let activeTab = 'buildings';
let activeSaveName = null;
let jsonEditorContent = null; // current textarea content when editable (preserved when switching tabs)

// JSON Editor tab is hidden until user clicks tabs in order: Buildings  Production  Shortfalls
const JSON_EDITOR_UNLOCK_SEQUENCE = ['buildings', 'production', 'shortfalls'];
let jsonEditorSequenceIndex = 0;
function isJsonEditorUnlocked() {
  try { return sessionStorage.getItem('rupture-json-editor-unlocked') === '1'; } catch (_) { return false; }
}
function setJsonEditorUnlocked() {
  try { sessionStorage.setItem('rupture-json-editor-unlocked', '1'); } catch (_) {}
}

const IDB_NAME = 'StarRuptureSaveMap';
const IDB_STORE = 'saveData';
const MAX_EDITABLE_JSON_SIZE = 1.5 * 1024 * 1024; // 1.5 MB  larger JSON is not shown in textarea to avoid timeout

function openIdb() {
  return new Promise((resolve, reject) => {
    const r = indexedDB.open(IDB_NAME, 1);
    r.onerror = () => reject(r.error);
    r.onsuccess = () => resolve(r.result);
    r.onupgradeneeded = (e) => { e.target.result.createObjectStore(IDB_STORE); };
  });
}

function saveRawJsonToIdb(jsonString) {
  return openIdb().then(db => {
    return new Promise((resolve, reject) => {
      const tx = db.transaction(IDB_STORE, 'readwrite');
      const store = tx.objectStore(IDB_STORE);
      store.put(jsonString, 'rawJson');
      tx.oncomplete = () => { db.close(); resolve(); };
      tx.onerror = () => reject(tx.error);
    });
  });
}

function getRawJsonFromIdb() {
  return openIdb().then(db => {
    return new Promise((resolve, reject) => {
      const tx = db.transaction(IDB_STORE, 'readonly');
      const req = tx.objectStore(IDB_STORE).get('rawJson');
      req.onsuccess = () => { db.close(); resolve(req.result != null ? req.result : null); };
      req.onerror = () => reject(req.error);
    });
  });
}

const MAX_JSON_SEARCH_RESULTS = 500;

function pathSegmentToKey(seg) {
  const s = (seg.length >= 2 && seg.startsWith('"') && seg.endsWith('"')) ? seg.slice(1, -1) : seg;
  return /^\d+$/.test(s) ? parseInt(s, 10) : s;
}

function getByPath(obj, pathStr) {
  if (!pathStr) return obj;
  const parts = pathStr.split('.').filter(Boolean);
  let cur = obj;
  for (const p of parts) {
    if (cur == null) return undefined;
    cur = cur[pathSegmentToKey(p)];
  }
  return cur;
}

function setByPath(obj, pathStr, value) {
  const parts = pathStr.split('.').filter(Boolean);
  if (parts.length === 0) return;
  let cur = obj;
  for (let i = 0; i < parts.length - 1; i++) {
    const key = pathSegmentToKey(parts[i]);
    if (cur[key] == null) return;
    cur = cur[key];
  }
  cur[pathSegmentToKey(parts[parts.length - 1])] = value;
}

function searchJson(obj, query, maxResults) {
  const q = (query || '').trim().toLowerCase();
  if (!q) return [];
  const results = [];
  function walk(o, path) {
    if (results.length >= maxResults) return;
    if (o === null || o === undefined) return;
    if (typeof o === 'string' || typeof o === 'number' || typeof o === 'boolean') {
      if (String(o).toLowerCase().includes(q)) results.push({ path, value: o, type: typeof o });
      return;
    }
    if (Array.isArray(o)) {
      o.forEach((v, i) => walk(v, path ? path + '.' + i : String(i)));
      return;
    }
    for (const [k, v] of Object.entries(o)) {
      const seg = /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(k) ? k : ('"' + k + '"');
      const nextPath = path ? path + '.' + seg : seg;
      const keyMatches = k.toLowerCase().includes(q);
      if (v === null || v === undefined) {
        if (keyMatches && results.length < maxResults) results.push({ path: nextPath, value: v, type: 'object' });
      } else if (typeof v === 'object' && !Array.isArray(v)) {
        walk(v, nextPath);
      } else if (Array.isArray(v)) {
        walk(v, nextPath);
      } else {
        if ((keyMatches || String(v).toLowerCase().includes(q)) && results.length < maxResults) {
          results.push({ path: nextPath, value: v, type: typeof v });
        }
      }
    }
  }
  walk(obj, '');
  return results;
}

/** Return unique parent paths that contain a match (so user can pick one and load its children). */
function searchJsonParentPaths(obj, query, maxResults) {
  const leafMatches = searchJson(obj, query, maxResults * 20);
  const parentSet = new Set();
  const parents = [];
  for (const m of leafMatches) {
    if (parents.length >= maxResults) break;
    const parts = m.path.split('.').filter(Boolean);
    if (parts.length === 0) continue;
    parts.pop();
    const parentPath = parts.join('.');
    if (parentPath && !parentSet.has(parentPath)) {
      parentSet.add(parentPath);
      parents.push(parentPath);
    }
  }
  return parents.sort((a, b) => a.localeCompare(b));
}

/** Collect all leaf paths and values under obj at basePath (basePath is full path from root). */
function getDescendantLeaves(obj, basePath) {
  const results = [];
  const subtree = basePath ? getByPath(obj, basePath) : obj;
  if (subtree === undefined) return results;
  function walk(o, prefix) {
    if (o === null || o === undefined) {
      results.push({ path: prefix, value: o, type: 'object' });
      return;
    }
    if (typeof o === 'string' || typeof o === 'number' || typeof o === 'boolean') {
      results.push({ path: prefix, value: o, type: typeof o });
      return;
    }
    if (Array.isArray(o)) {
      o.forEach((v, i) => walk(v, prefix ? prefix + '.' + i : String(i)));
      return;
    }
    for (const [k, v] of Object.entries(o)) {
      const seg = /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(k) ? k : ('"' + k + '"');
      const nextPath = prefix ? prefix + '.' + seg : seg;
      if (v === null || v === undefined) {
        results.push({ path: nextPath, value: v, type: 'object' });
      } else if (typeof v === 'object' && !Array.isArray(v)) {
        walk(v, nextPath);
      } else if (Array.isArray(v)) {
        walk(v, nextPath);
      } else {
        results.push({ path: nextPath, value: v, type: typeof v });
      }
    }
  }
  walk(subtree, basePath || '');
  return results;
}

// Per-tab state
let buildingsSearch = '';
let buildingsCollapsed = new Set();

let productionSearch = '';
let productionBuildingFilter = null;
let productionSortField = 'name';
let productionSortDir = 'asc';

let storageSearch = '';
let storageSortField = 'name';
let storageSortDir = 'asc';
let inventorySearch = '';
let inventorySortField = 'name';
let inventorySortDir = 'asc';

let dronesItemFilter = null;

let mapScale = 1;
let mapTranslateX = 0;
let mapTranslateY = 0;
let mapDragStart = null;
const MAP_DEFAULT_VISIBLE_CATEGORY = 'Crafting';
let mapBuildingVisibility = {};
let mapViewMode = 'buildings'; // 'buildings' | 'production'
let mapAreaVisibility = {}; // area id -> true/false; default true when undefined
let mapHighlightedAreaId = null; // area id highlighted in legend when clicking area on map
let productionAreaSearch = ''; // filter production legend to areas producing this item

// StarRuptureMap-style world-to-SVG transform (from StarRuptureMap main.go)
// Go uses full SVG 4352x5120; playable area is (380,567) to (3927,4038). We use content-only viewBox.
const MAP_SRC_X1 = -358583.0, MAP_DST_X1 = 380.0, MAP_SRC_X2 = -98583.0, MAP_DST_X2 = 3927.0;
const MAP_SRC_Y1 = -263782.0, MAP_DST_Y1 = 567.0, MAP_SRC_Y2 = -9439.0, MAP_DST_Y2 = 4038.0;
const MAP_SCALE_X = (MAP_DST_X2 - MAP_DST_X1) / (MAP_SRC_X2 - MAP_SRC_X1);
const MAP_SCALE_Y = (MAP_DST_Y2 - MAP_DST_Y1) / (MAP_SRC_Y2 - MAP_SRC_Y1);
const MAP_OFFSET_X = MAP_DST_X1 - MAP_SRC_X1 * MAP_SCALE_X;
const MAP_OFFSET_Y = MAP_DST_Y1 - MAP_SRC_Y1 * MAP_SCALE_Y;
const MAP_CONTENT_WIDTH = MAP_DST_X2 - MAP_DST_X1;
const MAP_CONTENT_HEIGHT = MAP_DST_Y2 - MAP_DST_Y1;
const MAP_IMAGE_WIDTH = 4352;
const MAP_IMAGE_HEIGHT = 5120;
const BASE_MAP_URL = 'https://raw.githubusercontent.com/bithoarder/StarRuptureMap/main/base_map.webp';
// Base core build area: axis-aligned square in world units (half of side length). Game uses this to limit where you can build.
const BASE_CORE_BUILD_HALF_EXTENT = 10000;

// Package sender: rail throughput (items/min). T1=120, T2=240, T3=480. Stack takes 10s to send after filling.
const PACKAGE_RAIL_RATE_T1 = 120;
const PACKAGE_RAIL_RATE_T2 = 240;
const PACKAGE_RAIL_RATE_T3 = 480;
const PACKAGE_SEND_DURATION_SEC = 10;
const PACKAGE_SENDER_DEFAULT_RAIL_RATE = PACKAGE_RAIL_RATE_T2; // when rail type not known from save
function packageSenderRate(itemsPerMinRail, requestedAmount) {
  if (!requestedAmount || requestedAmount <= 0) return 0;
  const cycleSec = (requestedAmount * 60) / itemsPerMinRail + PACKAGE_SEND_DURATION_SEC;
  return (requestedAmount * 60) / cycleSec;
}

function worldToMapCoords(worldX, worldY) {
  return {
    x: (worldX - MAP_SRC_X1) * MAP_SCALE_X,
    y: (worldY - MAP_SRC_Y1) * MAP_SCALE_Y
  };
}

// Entity type colors/sizes from StarRuptureMap (building InternalName -> { color, size })
const MAP_ENTITY_VISUAL = {
  'Package Sender': { color: '#8080ff', size: 3 },
  'Package Receiver': { color: '#8080ff', size: 3 },
  'Storage Depot v.1': { color: '#8080ff', size: 2 },
  'Storage Depot v.2': { color: '#8080ff', size: 3 },
  'Multistorage': { color: '#8080ff', size: 3 },
  'Solar Power Generator T1': { color: '#80ff80', size: 2 },
  'Solar Power Generator T2': { color: '#80ff80', size: 3 },
  'Wind Power Generator T1': { color: '#80ff80', size: 4 },
  'Base Core': { color: '#a0a0a0', size: 4 },
  'Passive Cooler': { color: '#ff8080', size: 2 },
  'Active Cooler': { color: '#ff8080', size: 4 },
  'Ore Extractor': { color: '#ffffff', size: 5 },
  'Helium-3 Extractor': { color: '#ffffff', size: 5 },
  'Sulfur Extractor': { color: '#ffffff', size: 5 },
  'Turret T1': { color: '#808080', size: 1 },
  'Smelter': { color: '#ffffff', size: 3 },
  'Fabricator': { color: '#ffffff', size: 3 },
  'Furnace': { color: '#ffffff', size: 3 },
  'Habitat (Small)': { color: '#808080', size: 5 },
  'Assembler': { color: '#ffffff', size: 3 },
  'Teleporter': { color: '#ffff00', size: 5 },
  'Refinery': { color: '#ffffff', size: 6 },
  'Compounder': { color: '#ffffff', size: 6 },
  'Mega Press': { color: '#ffffff', size: 4 },
  'Drone Rail Support': { color: '#8080ff', size: 1 },
  'Drone Junction': { color: '#8080ff', size: 1 },
  'Drone Merger (3-to-1)': { color: '#8080ff', size: 1 },
  'Drone Lane': { color: '#8080ff', size: 1 },
  'Drone Merger (5-to-1)': { color: '#8080ff', size: 1 }
};
function mapColorForBuilding(name) {
  const v = MAP_ENTITY_VISUAL[name];
  return v ? v.color : hashColor(name);
}
function mapSizeForBuilding(name) {
  const v = MAP_ENTITY_VISUAL[name];
  return (v ? v.size : 4) * 2.5;
}

// ===== DOM Helpers =====
const $ = (sel) => document.querySelector(sel);
const $$ = (sel) => document.querySelectorAll(sel);

function h(tag, attrs, ...children) {
  const el = document.createElement(tag);
  if (attrs) {
    for (const [k, v] of Object.entries(attrs)) {
      if (k === 'className') el.className = v;
      else if (k === 'onclick') el.addEventListener('click', v);
      else if (k === 'oninput') el.addEventListener('input', v);
      else if (k === 'onchange') el.addEventListener('change', v);
      else if (k.startsWith('data')) el.setAttribute(k, v);
      else el.setAttribute(k, v);
    }
  }
  for (const child of children) {
    if (child == null || child === false) continue;
    if (typeof child === 'string' || typeof child === 'number') {
      el.appendChild(document.createTextNode(String(child)));
    } else if (Array.isArray(child)) {
      child.forEach(c => { if (c) el.appendChild(c); });
    } else {
      el.appendChild(child);
    }
  }
  return el;
}

function setHTML(parent, ...children) {
  parent.innerHTML = '';
  for (const child of children) {
    if (child == null) continue;
    if (typeof child === 'string') {
      parent.innerHTML = child;
    } else {
      parent.appendChild(child);
    }
  }
}

// ===== Save File Parser (browser-side zlib via DecompressionStream) =====
async function decompressData(compressedBytes) {
  // Check for zlib header (0x78)
  const isZlib = compressedBytes.length >= 2 && compressedBytes[0] === 0x78;
  const format = isZlib ? 'deflate' : 'raw';

  // Try DecompressionStream first (modern browsers)
  if (typeof DecompressionStream !== 'undefined') {
    try {
      const ds = new DecompressionStream(format);
      const writer = ds.writable.getWriter();
      const reader = ds.readable.getReader();

      writer.write(compressedBytes);
      writer.close();

      const chunks = [];
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        chunks.push(value);
      }

      const totalLen = chunks.reduce((s, c) => s + c.length, 0);
      const result = new Uint8Array(totalLen);
      let offset = 0;
      for (const chunk of chunks) {
        result.set(chunk, offset);
        offset += chunk.length;
      }
      return new TextDecoder().decode(result);
    } catch (e) {
      // If 'raw' format failed, try 'deflate' as fallback
      if (format === 'raw') {
        try {
          const ds2 = new DecompressionStream('deflate');
          const writer2 = ds2.writable.getWriter();
          const reader2 = ds2.readable.getReader();
          writer2.write(compressedBytes);
          writer2.close();
          const chunks2 = [];
          while (true) {
            const { done, value } = await reader2.read();
            if (done) break;
            chunks2.push(value);
          }
          const totalLen2 = chunks2.reduce((s, c) => s + c.length, 0);
          const result2 = new Uint8Array(totalLen2);
          let off2 = 0;
          for (const chunk of chunks2) { result2.set(chunk, off2); off2 += chunk.length; }
          return new TextDecoder().decode(result2);
        } catch (e2) {
          throw new Error('Failed to decompress save file. The file may be corrupted.');
        }
      }
      throw new Error('Failed to decompress save file. ' + e.message);
    }
  }

  throw new Error('Your browser does not support DecompressionStream. Please use a modern browser (Chrome 80+, Edge 80+, Firefox 113+, Safari 16.4+).');
}

/** Compress JSON string to zlib (deflate) bytes for .sav format. */
async function compressToSavPayload(jsonString) {
  if (typeof CompressionStream === 'undefined') {
    throw new Error('Your browser does not support CompressionStream. Use a modern browser to save .sav files.');
  }
  const bytes = new TextEncoder().encode(jsonString);
  const stream = new ReadableStream({
    start(controller) {
      controller.enqueue(bytes);
      controller.close();
    }
  });
  const compressedStream = stream.pipeThrough(new CompressionStream('deflate'));
  const reader = compressedStream.getReader();
  const chunks = [];
  while (true) {
    const { done, value } = await reader.read();
    if (done) break;
    chunks.push(value);
  }
  const totalLen = chunks.reduce((s, c) => s + c.length, 0);
  const result = new Uint8Array(totalLen);
  let offset = 0;
  for (const chunk of chunks) {
    result.set(chunk, offset);
    offset += chunk.length;
  }
  return result;
}

/** Build full .sav file: 4-byte little-endian uncompressed size + zlib payload. */
async function buildSavFile(jsonString) {
  const payload = await compressToSavPayload(jsonString);
  const uncompressedSize = new TextEncoder().encode(jsonString).length;
  const out = new Uint8Array(4 + payload.length);
  const view = new DataView(out.buffer);
  view.setUint32(0, uncompressedSize, true); // little-endian
  out.set(payload, 4);
  return out;
}

async function parseSaveFile(file) {
  const buffer = await file.arrayBuffer();
  const fileData = new Uint8Array(buffer);

  if (fileData.length < 4) {
    throw new Error('Save file is too small. Expected at least 4 bytes for the header.');
  }

  // Skip the first 4 bytes (JSON size header)
  const compressedData = fileData.slice(4);
  return decompressData(compressedData);
}

// ===== Analyzer (ported from server/analyzer.ts) =====
function getJsonItems(parent, pathStr) {
  const names = pathStr.split('/').filter(Boolean);
  let result = parent;
  for (const name of names) {
    result = result[name];
    if (!result) throw new Error(`Invalid path ${pathStr} at ${name}`);
  }
  return result;
}

/** Item IDs that live under Weapons/AmmoTypes; all other items use /Game/Chimera/Items/. */
const AMMO_ITEM_IDS = new Set(['I_HeavyAmmoItem', 'I_PistolAmmoItem', 'I_ShotgunAmmo', 'I_StandardAmmoItem']);

function getStoragePathForItemId(itemId) {
  if (!itemId) return '';
  const base = AMMO_ITEM_IDS.has(itemId) ? '/Game/Chimera/Weapons/AmmoTypes/' : '/Game/Chimera/Items/';
  return base + itemId + '.' + itemId;
}

/** Build map item display name -> InternalName from ITEMS_DATA.Items. */
function getItemNameToInternalMap() {
  const m = {};
  for (const item of ITEMS_DATA.Items) {
    const name = (item.ItemName || '').trim();
    if (name && item.InternalName) m[name] = item.InternalName;
  }
  return m;
}

/** Build map item display name -> storage path for use in fragmentValues (Items vs Weapons/AmmoTypes). */
function getItemNameToStoragePathMap() {
  const m = {};
  for (const [id, displayName] of Object.entries(ITEMS_DATA.ItemNames || {})) {
    const name = (displayName || '').trim();
    if (name && id) m[name] = getStoragePathForItemId(id);
  }
  return m;
}

/** Parse ItemDataBase/Count from fragmentValues into Map(internalPath -> count). */
function parseStorageFragmentCounts(fragmentValues) {
  const counts = new Map();
  if (!Array.isArray(fragmentValues)) return counts;
  for (const fv of fragmentValues) {
    ITEM_DATA_REGEX.lastIndex = 0;
    const f = String(fv);
    let match;
    while ((match = ITEM_DATA_REGEX.exec(f)) !== null) {
      const path = match[1];
      const n = parseInt(match[2], 10);
      if (n > 0) counts.set(path, (counts.get(path) || 0) + n);
    }
  }
  return counts;
}

/** Serialize Map(internalPath -> count) to a single fragment string for storage. */
function serializeStorageFragment(countsByPath) {
  const parts = [];
  for (const [path, count] of countsByPath) {
    if (count > 0) parts.push('(ItemDataBase="' + path.replace(/"/g, '\\"') + '",Count=' + count + ')');
  }
  return parts.length ? parts.join('') : '';
}

/** Build a random 32-char hex handle for ItemId. */
function randomHandle32() {
  return Array(32).fill(0).map(() => Math.floor(Math.random() * 16).toString(16).toUpperCase()).join('');
}

/** Convert storage path to game ItemDataBase format: short_C'long' (e.g. I_Hydrolite.I_Hydrolite_C'/Game/.../Default__I_Hydrolite_C'). */
function toGameItemDataBase(storagePath) {
  if (!storagePath || typeof storagePath !== 'string') return '';
  const short = storagePath.endsWith('_C') ? storagePath : storagePath + '_C';
  const lastSlash = short.lastIndexOf('/');
  const dir = lastSlash >= 0 ? short.substring(0, lastSlash) : '';
  const segment = lastSlash >= 0 ? short.substring(lastSlash + 1) : short;
  const dot = segment.indexOf('.');
  const id = dot >= 0 ? segment.substring(0, dot) : segment;
  const long = dir + '/' + id + '.Default__' + id + '_C';
  return short + "'" + long + "'";
}

/** Serialize countsByPath (internalPath -> count) into a full CrInventoryFragment string the game can load. Matches game format: ItemDataBase uses short_C'long', slots have Column/Row. */
function serializeCrInventoryFragment(countsByPath) {
  const slotParts = [];
  let slotId = 1;
  const entries = [...countsByPath].filter(([, count]) => count > 0);
  for (let idx = 0; idx < entries.length; idx++) {
    const [path, count] = entries[idx];
    const itemDataBase = toGameItemDataBase(path);
    const escaped = itemDataBase.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
    const handle = randomHandle32();
    const column = idx % 8;
    const row = Math.floor(idx / 8);
    let slot = '(SlotID=(ID=' + slotId + '),Item=(ItemId=(Handle=' + handle + '),ItemDataBase="' + escaped + '",Count=' + count + '))';
    if (column > 0) slot += ',Column=' + column;
    if (row > 0) slot += ',Row=' + row;
    slot += ',ReplicationID=' + (idx + 1) + ',ReplicationKey=1)';
    slotParts.push(slot);
    slotId += 1;
  }
  if (slotParts.length === 0) return '';
  const itemsInner = '(' + slotParts.join(',') + ')';
  return '/Script/Chimera.CrInventoryFragment(InputInventoryContainer=(Items=,ArrayReplicationKey=0),MainInventoryContainer=(Items=(' + itemsInner + '),ArrayReplicationKey=' + slotParts.length + '),ItemThresholds=)';
}

/** Build Map(internalPath -> count) from itemsArray. Preserves Items vs Weapons/AmmoTypes path. */
function countsByPathFromItemsArray(itemsArray) {
  const counts = new Map();
  if (!Array.isArray(itemsArray)) return counts;
  for (const entry of itemsArray) {
    const path = getItemPathFromEntry(entry);
    if (!path) continue;
    const itemId = extractItemIdFromPath(path);
    if (!itemId) continue;
    const storagePath = getStoragePathForItemId(itemId);
    const amount = getAmountFromEntry(entry);
    if (amount > 0 && storagePath) counts.set(storagePath, (counts.get(storagePath) || 0) + amount);
  }
  return counts;
}

/** After editing itemsArray, sync the same inventory into character fragmentValues (CrInventoryFragment) so the game sees it. */
function syncItemsArrayToCharacterFragment(root, itemsArrayTarget) {
  if (!root || !itemsArrayTarget || !Array.isArray(itemsArrayTarget.itemsArray)) return;
  const counts = countsByPathFromItemsArray(itemsArrayTarget.itemsArray);
  const fragmentStr = serializeCrInventoryFragment(counts);
  if (!fragmentStr) return;
  const itemData = root.itemData;
  if (!itemData || typeof itemData !== 'object') return;
  const fragArrays = [];
  const playerState = itemData.CrPlayerState || itemData.PlayerState;
  if (playerState && Array.isArray(playerState.fragmentValues ?? playerState.FragmentValues)) fragArrays.push(playerState.fragmentValues ?? playerState.FragmentValues);
  const players = itemData.Players || itemData.players;
  if (Array.isArray(players)) for (const p of players) { if (p && Array.isArray(p.fragmentValues ?? p.FragmentValues)) fragArrays.push(p.fragmentValues ?? p.FragmentValues); }
  for (const key of ['Pawn', 'Character', 'LocalPlayerState', 'LocalPlayer']) {
    const o = itemData[key];
    if (o && Array.isArray(o.fragmentValues ?? o.FragmentValues)) fragArrays.push(o.fragmentValues ?? o.FragmentValues);
  }
  const mass = itemData.Mass;
  const entities = mass && mass.entities;
  if (entities && typeof entities === 'object') {
    for (const ev of Object.values(entities)) {
      if (ev && objectContains(ev, itemsArrayTarget, 0)) {
        const frag = ev.fragmentValues ?? ev.FragmentValues;
        if (Array.isArray(frag)) fragArrays.push(frag);
        break;
      }
    }
  }
  for (const frag of fragArrays) {
    for (let i = 0; i < frag.length; i++) {
      if (String(frag[i]).indexOf('CrInventoryFragment') !== -1) frag[i] = fragmentStr;
    }
  }
}

/** Collect all objects under itemData that have character-style itemsArray (for mirroring so the game sees inventory wherever it reads). Excludes Mass.entities. */
function getAllCharacterInventoryCandidates(root) {
  const itemData = root && root.itemData;
  if (!itemData || typeof itemData !== 'object') return [];
  const out = [];
  const seen = new Set();
  function add(obj) {
    if (!obj || typeof obj !== 'object' || seen.has(obj)) return;
    if (Array.isArray(obj.itemsArray) && looksLikeItemsArray(obj.itemsArray) && !looksLikeGemsArray(obj.itemsArray)) {
      seen.add(obj);
      out.push(obj);
    }
  }
  const topKeys = ['itemsStoreState', 'ItemsStoreState', 'InventoryFragment', 'CrInventoryFragment', 'CrPlayerState', 'PlayerState', 'Pawn', 'Character', 'LocalPlayerState', 'LocalPlayer'];
  for (const key of topKeys) {
    const o = itemData[key];
    if (o && typeof o === 'object') {
      add(o);
      const inv = o.InventoryFragment || o.itemsStoreState || o.ItemsStoreState;
      if (inv && typeof inv === 'object') add(inv);
    }
  }
  const players = itemData.Players || itemData.players;
  if (Array.isArray(players)) for (const p of players) {
    if (!p || typeof p !== 'object') continue;
    add(p);
    const inv = p.InventoryFragment || p.itemsStoreState || p.ItemsStoreState;
    if (inv && typeof inv === 'object') add(inv);
  }
  const skipKeys = new Set(['CrBuildingCustomNameSubsystem', 'CrPackageTransportReplicator', 'Mass', 'mass']);
  for (const k of Object.keys(itemData)) {
    if (skipKeys.has(k)) continue;
    const v = itemData[k];
    if (v && typeof v === 'object' && !Array.isArray(v)) {
      add(v);
      const inv = v.InventoryFragment || v.itemsStoreState || v.ItemsStoreState;
      if (inv && typeof inv === 'object') add(inv);
    }
  }
  return out;
}

/** Deep-clone itemsArray entries so mirrors are independent. */
function cloneItemsArray(arr) {
  if (!Array.isArray(arr)) return [];
  return arr.map((e) => (e && typeof e === 'object' ? { ...e, handle: e.handle && typeof e.handle === 'object' ? { ...e.handle } : e.handle, ownerId: e.ownerId && typeof e.ownerId === 'object' ? { ...e.ownerId } : e.ownerId, slotId: e.slotId && typeof e.slotId === 'object' ? { ...e.slotId } : e.slotId, ownerSlot: e.ownerSlot && typeof e.ownerSlot === 'object' ? { ...e.ownerSlot } : e.ownerSlot } : e));
}

/** Mirror primary inventory (itemsArray + fragment + ownedItems/inventoryState) to every other candidate under itemData so the game sees it regardless of which path it reads. */
function mirrorInventoryToAllCandidates(root, primaryTarget) {
  if (!root || !primaryTarget || !Array.isArray(primaryTarget.itemsArray)) return;
  const candidates = getAllCharacterInventoryCandidates(root);
  const sourceArr = primaryTarget.itemsArray;
  for (const candidate of candidates) {
    if (candidate === primaryTarget) continue;
    candidate.itemsArray = cloneItemsArray(sourceArr);
    candidate.arrayReplicationKey = sourceArr.length;
    if (candidate.ArrayReplicationKey !== undefined) candidate.ArrayReplicationKey = sourceArr.length;
    syncItemsArrayToCharacterFragment(root, candidate);
    syncOwnedItemsAndInventoryState(root, candidate);
  }
}

/** Find the object that contains itemsArrayTarget and has inventoryState (e.g. entity in Mass, or player in GameStateData.allPlayersSaveData). */
function findInventoryStateContainer(root, itemsArrayTarget) {
  const itemData = root && root.itemData;
  if (!itemData || !itemsArrayTarget) return null;
  const mass = itemData.Mass || itemData.mass;
  const entities = mass && mass.entities;
  if (entities && typeof entities === 'object') {
    for (const ev of Object.values(entities)) {
      if (ev && objectContains(ev, itemsArrayTarget, 0)) return ev;
    }
  }
  const gd = itemData.GameStateData;
  const ac = gd && (gd.allCharactersBaseSaveData || gd.AllCharactersBaseSaveData);
  const aps = ac && (ac.allPlayersSaveData || ac.AllPlayersSaveData);
  if (aps && typeof aps === 'object') {
    for (const player of Object.values(aps)) {
      if (player && objectContains(player, itemsArrayTarget, 0)) return player;
    }
  }
  return null;
}

/** When arr.length > totalSlots, sort by inventoryPriority (food first or crafted first) and trim to totalSlots. Mutates arr. */
function sortAndTrimItemsArrayByPriority(arr, totalSlots, priority, itemNames) {
  if (!Array.isArray(arr) || arr.length <= totalSlots || totalSlots <= 0) return;
  const getDisplayName = (e) => {
    const path = getItemPathFromEntry(e);
    if (!path) return '';
    const itemId = extractItemIdFromPath(path);
    return (itemId && itemNames && itemNames[itemId]) ? itemNames[itemId] : (itemId || '');
  };
  const foodFirst = priority !== 'craftedFirst';
  const order = (a, b) => {
    const nameA = getDisplayName(a);
    const nameB = getDisplayName(b);
    const aFood = nameA && FOOD_ITEM_NAMES.has(nameA);
    const bFood = nameB && FOOD_ITEM_NAMES.has(nameB);
    const aCrafted = nameA && CRAFTED_ITEM_NAMES.has(nameA);
    const bCrafted = nameB && CRAFTED_ITEM_NAMES.has(nameB);
    if (foodFirst) {
      if (aFood && !bFood) return -1;
      if (!aFood && bFood) return 1;
      if (aCrafted && !bCrafted) return -1;
      if (!aCrafted && bCrafted) return 1;
    } else {
      if (aCrafted && !bCrafted) return -1;
      if (!aCrafted && bCrafted) return 1;
      if (aFood && !bFood) return -1;
      if (!aFood && bFood) return 1;
    }
    return (nameA || '').localeCompare(nameB || '');
  };
  arr.sort(order);
  if (arr.length > totalSlots) arr.splice(totalSlots);
}

/** Sync ownedItems and inventoryState from itemsArray so the game can resolve handles. Call after merging/consolidating itemsArray. */
function syncOwnedItemsAndInventoryState(root, itemsArrayTarget) {
  if (!root || !itemsArrayTarget || !Array.isArray(itemsArrayTarget.itemsArray)) return;
  const arr = itemsArrayTarget.itemsArray;
  const getHandle = (e) => (e && e.handle && (e.handle.handle ?? e.handle.Handle)) || '';
  const container = findInventoryStateContainer(root, itemsArrayTarget);
  let totalSlots = 32;
  if (container) {
    const invState = container.inventoryState || container.InventoryState;
    if (invState && typeof invState === 'object') {
      const cols = invState.gridColumns != null ? invState.gridColumns : 8;
      const rows = invState.gridRows != null ? invState.gridRows : 4;
      totalSlots = Math.max(1, cols * rows);
    }
  }
  if (arr.length > totalSlots) {
    sortAndTrimItemsArrayByPriority(arr, totalSlots, inventoryPriority, ITEMS_DATA.ItemNames);
  }
  const ownedItems = arr.map((e) => ({ itemId: { handle: getHandle(e) } })).filter((o) => o.itemId.handle);
  if (itemsArrayTarget.ownedItems && Array.isArray(itemsArrayTarget.ownedItems)) {
    itemsArrayTarget.ownedItems.length = 0;
    itemsArrayTarget.ownedItems.push(...ownedItems);
  }
  if (!container) return;
  const invState = container.inventoryState || container.InventoryState;
  if (invState && typeof invState === 'object') {
    if (Array.isArray(invState.ownedItems)) {
      invState.ownedItems.length = 0;
      invState.ownedItems.push(...ownedItems);
    }
    if (Array.isArray(invState.slots)) {
      const cols = invState.gridColumns != null ? invState.gridColumns : 8;
      const rows = invState.gridRows != null ? invState.gridRows : 3;
      const slotsTotal = cols * rows;
      const usedIds = new Set();
      const nextId = () => { let n = 1; while (usedIds.has(n)) n++; usedIds.add(n); return n; };
      const zeroHandle = '00000000000000000000000000000000';
      const slots = [];
      for (let idx = 0; idx < slotsTotal; idx++) {
        const column = idx % cols;
        const row = Math.floor(idx / cols);
        const id = nextId();
        if (idx < arr.length) {
          const e = arr[idx];
          const itemIndex = idx;
          e.slotId = e.slotId && typeof e.slotId === 'object' ? e.slotId : {};
          e.slotId.iD = id;
          if (e.slotId.ID !== undefined) e.slotId.ID = id;
          e.ownerSlot = { iD: itemIndex };
          e.column = column;
          e.row = row;
          slots.push({
            itemId: { handle: getHandle(e) },
            slotId: { iD: id },
            column,
            row,
            ownerSlot: { iD: itemIndex }
          });
        } else {
          slots.push({
            itemId: { handle: zeroHandle },
            slotId: { iD: id },
            column,
            row,
            ownerSlot: { iD: -1 }
          });
        }
      }
      invState.slots.length = 0;
      invState.slots.push(...slots);
    }
  }
}

/** Returns true if arr looks like a character inventory itemsArray (has entries with item path and amount). */
function looksLikeItemsArray(arr) {
  if (!Array.isArray(arr) || arr.length === 0) return false;
  for (let i = 0; i < Math.min(arr.length, 5); i++) {
    const e = arr[i];
    if (!e || typeof e !== 'object') continue;
    const path = e.itemData || e.ItemData || (e.itemId && e.itemId.handle) || '';
    const amt = e.amount ?? e.Amount ?? e.count ?? e.Count;
    if ((typeof path === 'string' && path.indexOf('Chimera') !== -1) || (amt != null && Number(amt) > 0)) return true;
  }
  return false;
}

/** Returns true if arr looks like gems store (PlayerProgression/Gems), not main inventory. */
function looksLikeGemsArray(arr) {
  if (!Array.isArray(arr) || arr.length === 0) return false;
  for (let i = 0; i < Math.min(arr.length, 3); i++) {
    const e = arr[i];
    if (!e || typeof e !== 'object') continue;
    const path = String(e.itemData || e.ItemData || '');
    if (path.indexOf('PlayerProgression/Gems') !== -1 || path.indexOf('Gems/') !== -1) return true;
  }
  return false;
}

/** True if entity looks like the player (has character-only state like gems, weapons, inventory fragment). */
function entityLooksLikePlayer(ev) {
  if (!ev || typeof ev !== 'object') return false;
  if (ev.gemsStoreState != null || ev.weaponsState != null || ev.hiddenInventoryState != null) return true;
  const frag = ev.fragmentValues ?? ev.FragmentValues;
  if (Array.isArray(frag)) for (let i = 0; i < frag.length; i++) { if (String(frag[i]).indexOf('CrInventoryFragment') !== -1) return true; }
  const inv = ev.InventoryFragment || ev.itemsStoreState || ev.ItemsStoreState;
  if (inv && typeof inv === 'object' && Array.isArray(inv.itemsArray) && looksLikeItemsArray(inv.itemsArray) && !looksLikeGemsArray(inv.itemsArray)) return true;
  return false;
}

/** Recursively search for an object with itemsArray (e.g. InventoryFragment) under itemData. Max depth 6. */
function findItemsArrayUnder(obj, depth, skipKeys) {
  if (depth <= 0 || !obj || typeof obj !== 'object') return null;
  if (Array.isArray(obj)) {
    for (let i = 0; i < Math.min(obj.length, 3); i++) {
      const found = findItemsArrayUnder(obj[i], depth - 1, null);
      if (found) return found;
    }
    return null;
  }
  const keys = Object.keys(obj);
  for (const k of keys) {
    if (skipKeys && skipKeys.has(k)) continue;
    const v = obj[k];
    if (Array.isArray(v) && v.length > 0 && (k === 'itemsArray' || k === 'ItemsArray')) {
      if (looksLikeItemsArray(v) && !looksLikeGemsArray(v)) return obj;
    }
    if (v && typeof v === 'object') {
      const found = findItemsArrayUnder(v, depth - 1, null);
      if (found) return found;
    }
  }
  return null;
}

/** Try to find character/player inventory: object with fragmentValues, or object with itemsArray (itemsStoreState / InventoryFragment). Returns { target, style: 'fragmentValues'|'itemsArray' } or null. */
function getCharacterInventoryTarget(root) {
  const itemData = root && root.itemData;
  if (!itemData || typeof itemData !== 'object') return null;
  const skipKeys = new Set(['CrBuildingCustomNameSubsystem', 'CrPackageTransportReplicator']);
  const paths = [
    'itemData.itemsStoreState',
    'itemData.ItemsStoreState',
    'itemData.InventoryFragment',
    'itemData.CrInventoryFragment',
    'itemData.CrPlayerInventory',
    'itemData.PlayerInventory',
    'itemData.CharacterInventory',
    'itemData.CrCharacterInventory',
    'itemData.CrPlayerState',
    'itemData.PlayerState',
    'itemData.Pawn',
    'itemData.Character',
    'itemData.LocalPlayerState',
    'itemData.LocalPlayer'
  ];
  function hasFragmentValues(o) { return Array.isArray(o && (o.fragmentValues ?? o.FragmentValues)); }
  function getFragmentTarget(o) { return o && (o.fragmentValues ?? o.FragmentValues); }
  for (const path of paths) {
    const obj = getByPath(root, path);
    if (obj && typeof obj === 'object') {
      if (Array.isArray(obj.itemsArray) && looksLikeItemsArray(obj.itemsArray) && !looksLikeGemsArray(obj.itemsArray)) return { target: obj, style: 'itemsArray' };
      if (hasFragmentValues(obj)) return { target: Object.assign({}, obj, { fragmentValues: getFragmentTarget(obj) }), style: 'fragmentValues' };
    }
  }
  const players = itemData.Players || itemData.players;
  if (Array.isArray(players) && players.length > 0) {
    for (let i = 0; i < players.length; i++) {
      const p = players[i];
      if (p && typeof p === 'object') {
        if (Array.isArray(p.itemsArray) && looksLikeItemsArray(p.itemsArray) && !looksLikeGemsArray(p.itemsArray)) return { target: p, style: 'itemsArray' };
        if (hasFragmentValues(p)) return { target: Object.assign({}, p, { fragmentValues: getFragmentTarget(p) }), style: 'fragmentValues' };
        const inv = p.InventoryFragment || p.itemsStoreState || p.ItemsStoreState || p.inventory || p.Inventory || p.characterInventory || p.CharacterInventory;
        if (inv && typeof inv === 'object') {
          if (Array.isArray(inv.itemsArray) && looksLikeItemsArray(inv.itemsArray) && !looksLikeGemsArray(inv.itemsArray)) return { target: inv, style: 'itemsArray' };
          if (hasFragmentValues(inv)) return { target: Object.assign({}, inv, { fragmentValues: getFragmentTarget(inv) }), style: 'fragmentValues' };
        }
      }
    }
  }
  const playerState = itemData.CrPlayerState || itemData.PlayerState;
  if (playerState && typeof playerState === 'object') {
    const store = playerState.InventoryFragment || playerState.itemsStoreState || playerState.ItemsStoreState;
    if (store && typeof store === 'object' && Array.isArray(store.itemsArray) && looksLikeItemsArray(store.itemsArray) && !looksLikeGemsArray(store.itemsArray)) return { target: store, style: 'itemsArray' };
    if (hasFragmentValues(playerState)) return { target: Object.assign({}, playerState, { fragmentValues: getFragmentTarget(playerState) }), style: 'fragmentValues' };
  }
  const keys = Object.keys(itemData);
  for (const k of keys) {
    if (skipKeys.has(k)) continue;
    const v = itemData[k];
    if (v && typeof v === 'object' && !Array.isArray(v)) {
      if (Array.isArray(v.itemsArray) && looksLikeItemsArray(v.itemsArray) && !looksLikeGemsArray(v.itemsArray)) return { target: v, style: 'itemsArray' };
      if (hasFragmentValues(v)) return { target: Object.assign({}, v, { fragmentValues: getFragmentTarget(v) }), style: 'fragmentValues' };
    }
  }
  // Prefer player entity in Mass.entities (so we don't treat a building's storage as character inventory)
  const mass = itemData.Mass || itemData.mass;
  const massEntities = mass && mass.entities;
  if (massEntities && typeof massEntities === 'object') {
    for (const ev of Object.values(massEntities)) {
      if (!entityLooksLikePlayer(ev)) continue;
      const inv = ev.InventoryFragment || ev.itemsStoreState || ev.ItemsStoreState;
      if (inv && typeof inv === 'object' && Array.isArray(inv.itemsArray) && looksLikeItemsArray(inv.itemsArray) && !looksLikeGemsArray(inv.itemsArray))
        return { target: inv, style: 'itemsArray' };
      const nestedInv = findItemsArrayUnder(ev, 4, null);
      if (nestedInv) return { target: nestedInv, style: 'itemsArray' };
    }
  }
  const nested = findItemsArrayUnder(itemData, 6, skipKeys);
  if (nested) return { target: nested, style: 'itemsArray' };
  return null;
}

/** Build short item path for itemsArray (base + _C). */
function getItemPathForItemsArray(itemName, itemNameToStoragePath) {
  const base = itemNameToStoragePath[itemName];
  if (!base) return null;
  return base + '_C';
}

/** Full Unreal path format the game expects for itemsArray itemData (so new entries are accepted). */
function getFullItemPathForGame(basePath) {
  if (!basePath || typeof basePath !== 'string') return null;
  const seg = basePath.split('/').pop();
  const itemId = seg ? seg.split('.')[0] : null;
  if (!itemId) return basePath + '_C';
  const dir = basePath.substring(0, basePath.length - seg.length);
  return basePath + "_C'" + dir + itemId + '.Default__' + itemId + "_C'";
}

/** Merge refund into target that has itemsArray (InventoryFragment / itemsStoreState). Stack by same item (match by item id); new entries use full path format so the game accepts them. */
function mergeRefundIntoItemsArray(target, refundTotals, itemNameToStoragePath) {
  if (!target || !Array.isArray(target.itemsArray)) return false;
  const arr = target.itemsArray;
  let ownerHandle = null;
  for (const entry of arr) {
    const id = entry.ownerId || entry.ownerID;
    if (id && (id.handle || id.Handle)) { ownerHandle = (id.handle || id.Handle); break; }
  }
  if (!ownerHandle) ownerHandle = '00000000000000000000000000000000';
  for (const [itemName, addCount] of refundTotals) {
    const basePath = itemNameToStoragePath[itemName];
    if (!basePath || addCount <= 0) continue;
    const itemIdOnly = (basePath.split('/').pop() || '').split('.')[0];
    let merged = false;
    for (const entry of arr) {
      const existingPath = getItemPathFromEntry(entry);
      if (!existingPath) continue;
      const existingId = extractItemIdFromPath(existingPath);
      if (existingId && existingId === itemIdOnly) {
        entry.amount = (Number(entry.amount) || 0) + addCount;
        merged = true;
        break;
      }
    }
    if (!merged) {
      const itemPath = getItemPathForItemsArray(itemName, itemNameToStoragePath) || getFullItemPathForGame(basePath);
      const handle = Array(32).fill(0).map(() => Math.floor(Math.random() * 16).toString(16)).join('').toUpperCase();
      const slotId = getNextSlotIdForItemsArray(arr);
      const index = arr.length;
      const newEntry = {
        handle: { handle: handle },
        ownerId: { handle: ownerHandle },
        amount: addCount,
        componentHandles: [],
        componentsToAdd: [],
        itemStats: [],
        statsToGive: [],
        randomItemStats: { pool: [] },
        randomAttributes: { pool: [] },
        generatedGrantedEffects: [],
        generatedGrantedPassiveAbilities: [],
        itemData: itemPath
      };
      ensureEntrySlotAndPosition(newEntry, slotId, index);
      arr.push(newEntry);
    }
  }
  target.arrayReplicationKey = arr.length;
  if (target.ArrayReplicationKey !== undefined) target.ArrayReplicationKey = arr.length;
  return true;
}

/** Add one of a single item (by display name) to character inventory. Item must not already exist in inventory. Used for testing. Returns { ok, message?, itemName? }. */
function addOneNewItemToCharacterInventory(root, itemName) {
  const invResult = getCharacterInventoryTarget(root);
  if (!invResult) return { ok: false, message: 'No character inventory found.' };
  if (invResult.style !== 'itemsArray' || !Array.isArray(invResult.target.itemsArray)) return { ok: false, message: 'Character inventory is not itemsArray format.' };
  const itemNameToStoragePath = getItemNameToStoragePathMap();
  const basePath = itemNameToStoragePath[itemName];
  if (!basePath) return { ok: false, message: 'Unknown item: ' + itemName };
  const arr = invResult.target.itemsArray;
  const itemIdOnly = (basePath.split('/').pop() || '').split('.')[0];
  for (const entry of arr) {
    const existingPath = getItemPathFromEntry(entry);
    if (!existingPath) continue;
    const existingId = extractItemIdFromPath(existingPath);
    if (existingId && existingId === itemIdOnly) return { ok: false, message: 'Item already in inventory: ' + itemName };
  }
  let ownerHandle = null;
  for (const entry of arr) {
    const id = entry.ownerId || entry.ownerID;
    if (id && (id.handle || id.Handle)) { ownerHandle = (id.handle || id.Handle); break; }
  }
  if (!ownerHandle) ownerHandle = '00000000000000000000000000000000';
  const itemPath = getItemPathForItemsArray(itemName, itemNameToStoragePath) || getFullItemPathForGame(basePath);
  const handle = Array(32).fill(0).map(() => Math.floor(Math.random() * 16).toString(16)).join('').toUpperCase();
  const slotId = getNextSlotIdForItemsArray(arr);
  const index = arr.length;
  const newEntry = {
    handle: { handle: handle },
    ownerId: { handle: ownerHandle },
    amount: 1,
    componentHandles: [],
    componentsToAdd: [],
    itemStats: [],
    statsToGive: [],
    randomItemStats: { pool: [] },
    randomAttributes: { pool: [] },
    generatedGrantedEffects: [],
    generatedGrantedPassiveAbilities: [],
    itemData: itemPath
  };
  ensureEntrySlotAndPosition(newEntry, slotId, index);
  arr.push(newEntry);
  invResult.target.arrayReplicationKey = arr.length;
  if (invResult.target.ArrayReplicationKey !== undefined) invResult.target.ArrayReplicationKey = arr.length;
  syncItemsArrayToCharacterFragment(root, invResult.target);
  syncOwnedItemsAndInventoryState(root, invResult.target);
  mirrorInventoryToAllCandidates(root, invResult.target);
  return { ok: true, itemName };
}

/** Pick a display name from ItemNames that is not currently in character inventory (for "Add test item"). */
function pickItemNotInInventory(root) {
  const itemNames = ITEMS_DATA.ItemNames || {};
  const displayNames = [...new Set(Object.values(itemNames))].filter(Boolean).sort();
  const { items } = parseCharacterInventory(root, itemNames);
  const inInv = new Set(items.map((i) => i.name));
  for (const name of displayNames) {
    if (!inInv.has(name)) return name;
  }
  return null;
}

/** Consolidate itemsArray so there is one stack per item id (sum amounts). Each entry gets a unique slotId/column/row. Mutates target.itemsArray in place. */
function consolidateInventoryStacks(target) {
  if (!target || !Array.isArray(target.itemsArray)) return false;
  const arr = target.itemsArray;
  const byId = new Map();
  for (const entry of arr) {
    const path = getItemPathFromEntry(entry);
    if (!path) continue;
    const itemId = extractItemIdFromPath(path);
    if (!itemId) continue;
    const amount = getAmountFromEntry(entry);
    if (!byId.has(itemId)) {
      byId.set(itemId, { entry: { ...entry }, total: 0 });
    }
    const rec = byId.get(itemId);
    rec.total += amount;
  }
  let nextSlotId = getNextSlotIdForItemsArray(arr);
  const consolidated = [];
  let index = 0;
  for (const [, { entry, total }] of byId) {
    const one = { ...entry };
    one.amount = total;
    ensureEntrySlotAndPosition(one, nextSlotId, index);
    nextSlotId += 1;
    index += 1;
    consolidated.push(one);
  }
  target.itemsArray = consolidated;
  target.arrayReplicationKey = consolidated.length;
  if (target.ArrayReplicationKey !== undefined) target.ArrayReplicationKey = consolidated.length;
  return true;
}

/** Merge refund materials into an object that has fragmentValues (character inventory or storage entity). */
function mergeRefundIntoFragmentValues(target, refundTotals, itemNameToStoragePath) {
  if (!target || !Array.isArray(target.fragmentValues)) return false;
  const frag = target.fragmentValues;
  const countsByPath = parseStorageFragmentCounts(frag);
  for (const [itemName, addCount] of refundTotals) {
    const storagePath = itemNameToStoragePath[itemName];
    if (storagePath) countsByPath.set(storagePath, (countsByPath.get(storagePath) || 0) + addCount);
  }
  const newFragmentStr = serializeCrInventoryFragment(countsByPath);
  if (!newFragmentStr) return true;
  let replaced = false;
  for (let i = 0; i < frag.length; i++) {
    if (String(frag[i]).indexOf('CrInventoryFragment') !== -1 || String(frag[i]).indexOf('ItemDataBase=') !== -1) {
      frag[i] = newFragmentStr;
      replaced = true;
      break;
    }
  }
  if (!replaced) frag.push(newFragmentStr);
  return true;
}

/** True if item should not be transferred from storage to personal inventory (Wolfram*, Titanium*, Calcium*). */
function shouldExcludeFromStorageTransfer(itemName) {
  if (!itemName || typeof itemName !== 'string') return true;
  const n = itemName.toLowerCase();
  return n.includes('wolfram') || n.includes('titanium') || n.includes('calcium');
}

/** Return true if target is the same reference as obj or any nested object under obj (max depth 12). */
function objectContains(obj, target, depth) {
  if (depth > 12 || obj == null) return false;
  if (obj === target) return true;
  if (typeof obj !== 'object') return false;
  if (Array.isArray(obj)) {
    for (let i = 0; i < obj.length; i++) if (objectContains(obj[i], target, depth + 1)) return true;
    return false;
  }
  for (const k of Object.keys(obj)) if (objectContains(obj[k], target, depth + 1)) return true;
  return false;
}

/** Parse entity key "(ID=123)" to number 123. */
function parseEntityIdNum(key) {
  if (typeof key !== 'string') return null;
  const m = key.match(/^\(ID=(\d+)\)$/);
  return m ? parseInt(m[1], 10) : null;
}

/** Get entities from reference save that are NOT the character-inventory entity (so we can restore buildings). Returns Map of entityKey -> entity (cloned). */
function getBuildingEntitiesFromReference(refRoot) {
  const itemData = refRoot && refRoot.itemData;
  if (!itemData || typeof itemData !== 'object') return new Map();
  const mass = itemData.Mass || itemData.mass;
  const entities = mass && mass.entities;
  if (!entities || typeof entities !== 'object') return new Map();
  const characterInvResult = getCharacterInventoryTarget(refRoot);
  const entityIdContainingInventory = characterInvResult && characterInvResult.target
    ? (() => { for (const [id, ev] of Object.entries(entities)) { if (ev && objectContains(ev, characterInvResult.target, 0)) return id; } return null; })()
    : null;
  const out = new Map();
  for (const [id, ev] of Object.entries(entities)) {
    if (!ev || id === entityIdContainingInventory) continue;
    try {
      out.set(id, JSON.parse(JSON.stringify(ev)));
    } catch (e) { /* skip if not cloneable */ }
  }
  return out;
}

/** Return default building entities embedded in the page (from initialstate). Cached after first parse. Supports raw JSON or data-encoding="base64-deflate". */
async function getDefaultBuildingEntities() {
  if (window.__defaultBuildingEntities !== undefined) return window.__defaultBuildingEntities;
  try {
    const el = document.getElementById('default-building-entities');
    if (!el || !el.textContent || !el.textContent.trim()) { window.__defaultBuildingEntities = {}; return window.__defaultBuildingEntities; }
    const raw = el.textContent.trim();
    const encoding = el.getAttribute('data-encoding');
    if (encoding === 'base64-deflate') {
      const binary = atob(raw);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
      const jsonString = await decompressData(bytes);
      window.__defaultBuildingEntities = JSON.parse(jsonString);
    } else {
      window.__defaultBuildingEntities = JSON.parse(raw);
    }
  } catch (e) { window.__defaultBuildingEntities = {}; }
  return window.__defaultBuildingEntities;
}

/** Add default building entities into current save's Mass.entities. Assigns new IDs where current save already uses that ID. Returns { added, skipped }. */
async function addDefaultBuildingsToCurrent(currentRoot) {
  const currentItemData = currentRoot && currentRoot.itemData;
  if (!currentItemData || typeof currentItemData !== 'object') return { added: 0, skipped: 0 };
  const currentMass = currentItemData.Mass || currentItemData.mass;
  if (!currentMass || typeof currentMass !== 'object') return { added: 0, skipped: 0 };
  let currentEntities = currentMass.entities;
  if (!currentEntities || typeof currentEntities !== 'object') {
    currentMass.entities = {};
    currentEntities = currentMass.entities;
  }
  const defaultEntities = await getDefaultBuildingEntities();
  if (!defaultEntities || typeof defaultEntities !== 'object' || Object.keys(defaultEntities).length === 0) return { added: 0, skipped: 0 };
  const usedIdNums = new Set();
  for (const key of Object.keys(currentEntities)) {
    const n = parseEntityIdNum(key);
    if (n != null) usedIdNums.add(n);
  }
  let nextFreeId = 1;
  while (usedIdNums.has(nextFreeId)) nextFreeId++;
  let added = 0;
  let skipped = 0;
  for (const [refKey, entity] of Object.entries(defaultEntities)) {
    const refIdNum = parseEntityIdNum(refKey);
    const keyToUse = refIdNum != null && !usedIdNums.has(refIdNum) ? refKey : '(ID=' + nextFreeId + ')';
    if (refIdNum != null && !usedIdNums.has(refIdNum)) usedIdNums.add(refIdNum);
    else { usedIdNums.add(nextFreeId); nextFreeId++; while (usedIdNums.has(nextFreeId)) nextFreeId++; }
    if (currentEntities[keyToUse] != null) { skipped++; continue; }
    try {
      currentEntities[keyToUse] = JSON.parse(JSON.stringify(entity));
    } catch (e) { skipped++; continue; }
    added++;
  }
  return { added, skipped };
}

/** Remove all user-created entities (including storage containers). Refunds build materials and moves storage contents
 * into character inventory (excluding Wolfram/Titanium/Calcium items), stacked by item type.
 * Does NOT remove the entity that contains the character inventory (so merged items persist).
 * Returns { removed, materialsAdded, addedTo }. */
async function removeUserCreatedObjects(root) {
  const itemData = root && root.itemData;
  if (!itemData || typeof itemData !== 'object') return { removed: 0, materialsAdded: {}, addedTo: null };
  const mass = itemData.Mass;
  if (!mass || typeof mass !== 'object') return { removed: 0, materialsAdded: {}, addedTo: null };
  const entities = mass.entities;
  if (!entities || typeof entities !== 'object') return { removed: 0, materialsAdded: {}, addedTo: null };

  const characterInvResult = getCharacterInventoryTarget(root);
  const entityIdContainingInventory = characterInvResult && characterInvResult.target
    ? (() => { for (const [id, ev] of Object.entries(entities)) { if (ev && objectContains(ev, characterInvResult.target, 0)) return id; } return null; })()
    : null;

  const buildingsByInternal = new Map();
  for (const b of ITEMS_DATA.Buildings) buildingsByInternal.set(b.InternalName, b);
  const itemNameToStoragePath = getItemNameToStoragePathMap();
  const toRemove = [];
  const refundTotals = new Map(); // itemName -> count
  const storageContentsToMerge = new Map(); // itemName -> count (from storage containers, excluding Wolfram/Titanium/Calcium)

  const baseCoreLevelByEntityId = getBaseCoreLevelMapFromSaveData(itemData);
  const itemNames = ITEMS_DATA.ItemNames || {};
  for (const [entityIdKey, entityValue] of Object.entries(entities)) {
    if (!entityValue) continue;
    if (entityIdKey === entityIdContainingInventory) continue;
    const spawnData = entityValue.spawnData ?? entityValue.SpawnData;
    if (!spawnData || typeof spawnData !== 'object') continue;
    const path = String((spawnData.entityConfigDataPath ?? spawnData.EntityConfigDataPath) || '');
    toRemove.push(entityIdKey);
    const buildingDef = buildingsByInternal.get(path);
    const buildingName = buildingDef ? buildingDef.Name : null;
    const cost = getBuildingBuildCost(buildingName || '');
    for (const { itemName, amount } of cost) {
      if (amount > 0) refundTotals.set(itemName, (refundTotals.get(itemName) || 0) + amount);
    }
    if (buildingName === 'Base Core') {
      const idMatch = String(entityIdKey).match(/^\(ID=(\d+)\)$/);
      const entityIdNum = idMatch ? parseInt(idMatch[1], 10) : null;
      const baseCoreLevel = (entityIdNum != null && baseCoreLevelByEntityId.has(entityIdNum))
        ? baseCoreLevelByEntityId.get(entityIdNum)
        : getBaseCoreLevelFromEntity(entityValue);
      const meteoriteHeartRefund = getBaseCoreMeteoriteHeartRefundForLevel(baseCoreLevel);
      if (meteoriteHeartRefund > 0) refundTotals.set('Meteorite Heart', (refundTotals.get('Meteorite Heart') || 0) + meteoriteHeartRefund);
      const ignitiumRefund = getBaseCoreIgnitiumRefundForLevel(baseCoreLevel);
      if (ignitiumRefund > 0) refundTotals.set('Ignitium', (refundTotals.get('Ignitium') || 0) + ignitiumRefund);
    }
    // Drain items from all buildings (storage, personal storage, crafting buffers, turret ammo, etc.) into storageContentsToMerge
    const frag = entityValue.fragmentValues ?? entityValue.FragmentValues;
    if (Array.isArray(frag)) {
      const tempStorage = new Map();
      parseStoredItems(frag, tempStorage, itemNames);
      for (const [itemName, count] of tempStorage) {
        if (!shouldExcludeFromStorageTransfer(itemName) && count > 0)
          storageContentsToMerge.set(itemName, (storageContentsToMerge.get(itemName) || 0) + count);
      }
    }
    // Also drain from itemsArray if present on entity (some saves use this instead of fragmentValues)
    const itemsObj = entityValue.itemsArray != null ? entityValue : findItemsArrayUnder(entityValue, 4, null);
    const entityItemsArray = itemsObj && (itemsObj.itemsArray || itemsObj.ItemsArray);
    if (Array.isArray(entityItemsArray) && looksLikeItemsArray(entityItemsArray) && !looksLikeGemsArray(entityItemsArray)) {
      for (const entry of entityItemsArray) {
        const path = getItemPathFromEntry(entry);
        if (!path) continue;
        const amount = getAmountFromEntry(entry);
        if (amount <= 0) continue;
        const itemId = extractItemIdFromPath(path);
        if (!itemId) continue;
        const displayName = resolveItemName(itemId, itemNames);
        if (!shouldExcludeFromStorageTransfer(displayName))
          storageContentsToMerge.set(displayName, (storageContentsToMerge.get(displayName) || 0) + amount);
      }
    }
  }

  for (const [itemName, count] of storageContentsToMerge) {
    if (count > 0) refundTotals.set(itemName, (refundTotals.get(itemName) || 0) + count);
  }

  const removedSet = new Set(toRemove);
  const removedIdNum = new Set();
  for (const id of toRemove) {
    const m = String(id).match(/^\(ID=(\d+)\)$/);
    if (m) removedIdNum.add(parseInt(m[1], 10));
  }
  function isRemovedEntity(keyOrId) {
    if (removedSet.has(String(keyOrId))) return true;
    const m = String(keyOrId).match(/^\(ID=(\d+)\)$/);
    if (m && removedIdNum.has(parseInt(m[1], 10))) return true;
    if (typeof keyOrId === 'number' && removedIdNum.has(keyOrId)) return true;
    return false;
  }

  for (const id of toRemove) delete entities[id];
  const customNames = itemData.CrBuildingCustomNameSubsystem && itemData.CrBuildingCustomNameSubsystem.customNames;
  if (customNames && typeof customNames === 'object') {
    for (const id of toRemove) delete customNames[id];
  }

  try {
    const senderConnections = itemData.CrPackageTransportReplicator && itemData.CrPackageTransportReplicator.senderConnections;
    if (senderConnections && typeof senderConnections === 'object') {
      for (const senderId of Object.keys(senderConnections)) {
        const cfg = senderConnections[senderId];
        const rec = cfg && (cfg.receiver || cfg.Receiver);
        const recId = rec && (rec.iD != null ? rec.iD : rec.ID);
        const receiverKey = recId != null ? '(ID=' + recId + ')' : null;
        if (isRemovedEntity(senderId) || (receiverKey != null && isRemovedEntity(receiverKey))) {
          delete senderConnections[senderId];
        }
      }
    }
  } catch (_) {}

  try {
    const logistics = mass.logisticsRequestSubsystemState || mass.LogisticsRequestSubsystemState;
    const requestData = logistics && logistics.requestData;
    if (requestData && typeof requestData === 'object') {
      for (const reqKey of Object.keys(requestData)) {
        const req = requestData[reqKey];
        if (!req || typeof req !== 'object') continue;
        const requesterRef = req.requesterEntity || req.RequesterEntity;
        const requesterId = requesterRef != null && (requesterRef.iD != null || requesterRef.ID != null)
          ? '(ID=' + (requesterRef.iD != null ? requesterRef.iD : requesterRef.ID) + ')'
          : null;
        if (isRemovedEntity(reqKey) || (requesterId != null && isRemovedEntity(requesterId))) {
          delete requestData[reqKey];
          continue;
        }
        const runtimeData = req.runtimeData || req.RuntimeData;
        if (Array.isArray(runtimeData)) {
          const kept = runtimeData.filter(rt => {
            if (!rt || typeof rt !== 'object') return false;
            const agentRef = rt.agentEntity || rt.AgentEntity;
            const agentId = agentRef != null && (agentRef.iD != null || agentRef.ID != null)
              ? '(ID=' + (agentRef.iD != null ? agentRef.iD : agentRef.ID) + ')'
              : null;
            return agentId == null || !isRemovedEntity(agentId);
          });
          req.runtimeData = kept;
          if (req.RuntimeData) req.RuntimeData = kept;
        }
      }
    }
  } catch (_) {}

  const materialsAdded = {};
  for (const [k, v] of refundTotals) materialsAdded[k] = v;
  let addedTo = null;

  if (refundTotals.size > 0) {
    if (characterInvResult) {
      const ok = characterInvResult.style === 'itemsArray'
        ? (mergeRefundIntoItemsArray(characterInvResult.target, refundTotals, itemNameToStoragePath) && consolidateInventoryStacks(characterInvResult.target) && (syncOwnedItemsAndInventoryState(root, characterInvResult.target), syncItemsArrayToCharacterFragment(root, characterInvResult.target), mirrorInventoryToAllCandidates(root, characterInvResult.target), true))
        : mergeRefundIntoFragmentValues(characterInvResult.target, refundTotals, itemNameToStoragePath);
      if (ok) addedTo = 'character';
    }
    if (!addedTo) {
      let firstPersonalStorageEntity = null;
      for (const entityValue of Object.values(entities)) {
        if (!entityValue) continue;
        const spawnData = entityValue.spawnData ?? entityValue.SpawnData;
        if (!spawnData) continue;
        const path = String(spawnData.entityConfigDataPath ?? spawnData.EntityConfigDataPath ?? '');
        if (path.toLowerCase().includes('personalstorage')) {
          firstPersonalStorageEntity = entityValue;
          break;
        }
      }
      if (firstPersonalStorageEntity && mergeRefundIntoFragmentValues(firstPersonalStorageEntity, refundTotals, itemNameToStoragePath)) {
        addedTo = 'personalStorage';
      }
    }
  }

  const defaultRestored = await addDefaultBuildingsToCurrent(root);
  const storageCollected = storageContentsToMerge.size;
  const storageTypes = storageCollected ? [...storageContentsToMerge.keys()].slice(0, 10).join(', ') + (storageContentsToMerge.size > 10 ? '' : '') : '';
  return { removed: toRemove.length, materialsAdded, addedTo, storageCollected, storageTypes, characterInvFound: !!characterInvResult, defaultBuildingsRestored: defaultRestored.added };
}

function getSelectedRecipe(fragment) {
  const i = fragment.indexOf('SelectedRecipe=');
  if (i < 0) return null;
  let sub = fragment.substring(i + 15);
  if (!sub.startsWith('"')) return null;
  const j = sub.indexOf('"', 1);
  if (j < 0) return null;
  sub = sub.substring(1, j);
  const prefix = "/Script/Chimera.CrItemRecipeData'";
  if (sub.startsWith(prefix)) {
    sub = sub.substring(prefix.length, sub.length - 1);
  }
  return sub;
}

function extractItemIdentifier(itemDataBase) {
  const prefix = '/Game/Chimera/Items/';
  const idx = itemDataBase.indexOf(prefix);
  if (idx < 0) return null;
  let sub = itemDataBase.substring(idx + prefix.length);
  const dotIdx = sub.indexOf('.');
  if (dotIdx > 0) sub = sub.substring(0, dotIdx);
  return sub;
}

function resolveItemName(itemId, itemNames) {
  if (itemNames[itemId]) return itemNames[itemId];
  let name = itemId;
  if (name.startsWith('I_')) name = name.substring(2);
  name = name.replace(/(?<!^)([A-Z])/g, ' $1');
  return name;
}

/** Get item path string from an itemsArray entry (may be itemData, ItemData, or Item.ItemDataBase from game save). */
function getItemPathFromEntry(entry) {
  if (!entry || typeof entry !== 'object') return null;
  const path = entry.itemData || entry.ItemData;
  if (typeof path === 'string') return path;
  const item = entry.Item || entry.item;
  if (item && typeof item === 'object') {
    const base = item.ItemDataBase || item.itemDataBase;
    if (typeof base === 'string') return base.indexOf("'") >= 0 ? base.substring(0, base.indexOf("'")) : base;
  }
  const base = entry.ItemDataBase || entry.itemDataBase;
  if (typeof base === 'string') return base.indexOf("'") >= 0 ? base.substring(0, base.indexOf("'")) : base;
  return null;
}

/** Get count from an itemsArray entry. */
function getAmountFromEntry(entry) {
  if (!entry || typeof entry !== 'object') return 0;
  const n = entry.amount ?? entry.Amount ?? entry.count ?? entry.Count;
  return Math.max(0, parseInt(n, 10) || 0);
}

/** Get slot id number from an itemsArray entry (slotId.iD or slotId.ID). */
function getSlotIdFromEntry(entry) {
  if (!entry || typeof entry !== 'object') return null;
  const slot = entry.slotId || entry.slotID || entry.SlotId || entry.SlotID;
  if (!slot || typeof slot !== 'object') return null;
  const id = slot.iD ?? slot.ID;
  return typeof id === 'number' ? id : null;
}

/** Get the next unique slot id to use (max existing + 1). Inventory grid is typically 8 columns. */
function getNextSlotIdForItemsArray(arr) {
  let max = 0;
  for (const entry of arr || []) {
    const id = getSlotIdFromEntry(entry);
    if (id != null && id > max) max = id;
  }
  return max + 1;
}

const INVENTORY_GRID_COLUMNS = 8;

/** Ensure an itemsArray entry has unique slotId, column, row, ownerSlot. Mutates entry; returns the handle string for ownerSlot. */
function ensureEntrySlotAndPosition(entry, slotId, index) {
  const handleStr = (entry.handle && (entry.handle.handle || entry.handle.Handle)) || Array(32).fill(0).map(() => Math.floor(Math.random() * 16).toString(16)).join('').toUpperCase();
  if (entry.handle == null) entry.handle = { handle: handleStr };
  else if (typeof entry.handle === 'object' && !entry.handle.handle && !entry.handle.Handle) entry.handle.handle = handleStr;
  entry.slotId = { iD: slotId };
  entry.column = index % INVENTORY_GRID_COLUMNS;
  entry.row = Math.floor(index / INVENTORY_GRID_COLUMNS);
  entry.ownerSlot = entry.ownerSlot || {};
  if (!entry.ownerSlot.handle && !entry.ownerSlot.Handle) entry.ownerSlot.handle = handleStr;
  return handleStr;
}

/** Extract item id from path (e.g. I_HeavyAmmoItem from .../Weapons/AmmoTypes/I_HeavyAmmoItem.I_HeavyAmmoItem_C). */
function extractItemIdFromPath(path) {
  const fromItems = extractItemIdentifier(path);
  if (fromItems) return fromItems;
  const match = String(path).match(/I_[A-Za-z0-9_]+/);
  return match ? match[0] : null;
}

/** Parse character/player inventory from root (itemsStoreState / InventoryFragment or fragmentValues). Returns { name, count }[] and total count. */
function parseCharacterInventory(root, itemNames) {
  const invResult = getCharacterInventoryTarget(root);
  if (!invResult) return { items: [], total: 0 };
  const byName = new Map();
  if (invResult.style === 'itemsArray' && Array.isArray(invResult.target.itemsArray)) {
    for (const entry of invResult.target.itemsArray) {
      const path = getItemPathFromEntry(entry);
      if (!path) continue;
      const itemId = extractItemIdFromPath(path);
      const displayName = itemId ? resolveItemName(itemId, itemNames) : path;
      const amount = getAmountFromEntry(entry);
      if (amount > 0) byName.set(displayName, (byName.get(displayName) || 0) + amount);
    }
  } else if (invResult.style === 'fragmentValues' && Array.isArray(invResult.target.fragmentValues)) {
    parseStoredItems(invResult.target.fragmentValues, byName, itemNames);
  }
  const items = [];
  for (const [name, count] of byName) items.push({ name, count });
  items.sort((a, b) => a.name.localeCompare(b.name));
  const total = items.reduce((s, i) => s + i.count, 0);
  return { items, total };
}

// Extract world position from spawnData (Unreal may use Location, Transform.Translation, etc.)
function extractPosition(spawnData) {
  if (!spawnData || typeof spawnData !== 'object') return null;
  function getVec(obj) {
    if (!obj || typeof obj !== 'object') return null;
    const parse = (v) => (typeof v === 'number' && !Number.isNaN(v)) ? v : (typeof v === 'string' ? Number(v) : NaN);
    const x = parse(obj.x ?? obj.X);
    const y = parse(obj.y ?? obj.Y);
    const z = parse(obj.z ?? obj.Z);
    if (Number.isNaN(x) || Number.isNaN(y) || Number.isNaN(z)) return null;
    return { x, y, z };
  }
  const loc = getVec(spawnData.location) ?? getVec(spawnData.Location) ?? getVec(spawnData.position) ?? getVec(spawnData.Position) ?? getVec(spawnData.relativeLocation) ?? getVec(spawnData.RelativeLocation);
  if (loc) return loc;
  const trans = spawnData.transform ?? spawnData.Transform;
  if (trans && typeof trans === 'object') {
    const transLoc = getVec(trans.translation ?? trans.Translation ?? trans.location ?? trans.Location);
    if (transLoc) return transLoc;
  }
  return null;
}

// Extract custom/display name from entity (spawnData or fragmentValues)
function extractDisplayName(entityValue, spawnData) {
  if (!entityValue || typeof entityValue !== 'object') return null;
  const str = (v) => (v != null && typeof v === 'string' && v.trim().length > 0) ? v.trim() : null;
  const fromObj = (obj, keys) => {
    if (!obj || typeof obj !== 'object') return null;
    for (const key of keys) {
      const v = obj[key];
      if (str(v)) return v;
    }
    return null;
  };
  let name = fromObj(spawnData, ['displayName', 'DisplayName', 'customName', 'CustomName', 'label', 'Label', 'buildingName', 'BuildingName', 'friendlyName', 'FriendlyName']);
  if (name) return name;
    const fragmentValues = entityValue['fragmentValues'] ?? entityValue['FragmentValues'];
    if (Array.isArray(fragmentValues)) {
    const keys = 'DisplayName|CustomName|Label|BuildingName|FriendlyName|ReceiverName|StationName|CustomLabel|EntityName';
    for (const fv of fragmentValues) {
      const s = String(fv);
      let m = s.match(new RegExp('(?:' + keys + ')=["\']([^"\']+)["\']', 'i'));
      if (!m) m = s.match(new RegExp('(?:' + keys + ')=([^\\s)\\]",]+)', 'i'));
      if (m && m[1]) {
        const val = m[1].trim();
        if (val.length > 0 && !val.startsWith('/') && !val.startsWith('Script')) return val;
      }
    }
  }
  return null;
}

// Extract scale from spawnData (Unreal may use Scale, Scale3D, or transform.Scale)
function extractScale(spawnData) {
  if (!spawnData || typeof spawnData !== 'object') return null;
  function getVec(obj) {
    if (!obj || typeof obj !== 'object') return null;
    const parse = (v) => (typeof v === 'number' && !Number.isNaN(v)) ? v : (typeof v === 'string' ? Number(v) : NaN);
    const x = parse(obj.x ?? obj.X);
    const y = parse(obj.y ?? obj.Y);
    const z = parse(obj.z ?? obj.Z);
    if (Number.isNaN(x) && Number.isNaN(y) && Number.isNaN(z)) return null;
    const sx = Number.isNaN(x) ? 1 : x;
    const sy = Number.isNaN(y) ? 1 : y;
    const sz = Number.isNaN(z) ? 1 : z;
    return { x: sx, y: sy, z: sz };
  }
  const scale = getVec(spawnData.scale) ?? getVec(spawnData.Scale) ?? getVec(spawnData.scale3D) ?? getVec(spawnData.Scale3D);
  if (scale) return scale;
  const trans = spawnData.transform ?? spawnData.Transform;
  if (trans && typeof trans === 'object') {
    const transScale = getVec(trans.scale ?? trans.Scale ?? trans.scale3D ?? trans.Scale3D);
    if (transScale) return transScale;
  }
  return null;
}

/** Match ItemDataBase="path",Count=N. Permissive regex allows \" inside path. */
const ITEM_DATA_REGEX = /ItemDataBase="([^"]+)"[^)]*?Count=(\d+)/g;
const ITEM_DATA_REGEX_ESCAPED = /ItemDataBase=\\?"((?:[^"\\]|\\.)*)"[^)]*?Count=(\d+)/g;

function parseStoredItems(fragmentValues, storage, itemNames) {
  for (const fragmentValue of fragmentValues) {
    const f = String(fragmentValue);
    const re = f.indexOf('ItemDataBase=\\"') !== -1 ? ITEM_DATA_REGEX_ESCAPED : ITEM_DATA_REGEX;
    re.lastIndex = 0;
    let match;
    while ((match = re.exec(f)) !== null) {
      let itemDataBase = match[1];
      if (itemDataBase.indexOf('\\') !== -1) itemDataBase = itemDataBase.replace(/\\./g, (c) => c === '\\"' ? '"' : c);
      const count = parseInt(match[2], 10);
      if (count <= 0) continue;
      const shortPath = itemDataBase.indexOf("'") >= 0 ? itemDataBase.substring(0, itemDataBase.indexOf("'")) : itemDataBase;
      const itemId = extractItemIdentifier(shortPath) || extractItemIdFromPath(shortPath) || extractItemIdFromPath(itemDataBase);
      if (!itemId) continue;
      const displayName = resolveItemName(itemId, itemNames);
      storage.set(displayName, (storage.get(displayName) || 0) + count);
    }
  }
}

function analyze(jsonContent) {
  const data = ITEMS_DATA;
  const itemsForAnalysis = ITEMS_FOR_ANALYSIS;
  const recipeInputsForAnalysis = RECIPE_INPUTS_FOR_ANALYSIS;

  const buildingsByInternal = new Map();
  for (const b of data.Buildings) buildingsByInternal.set(b.InternalName, b);

  const itemsByInternal = new Map();
  for (const item of itemsForAnalysis) itemsByInternal.set(item.InternalName, item);

  const root = JSON.parse(jsonContent);
  const entities = getJsonItems(root, 'itemData/Mass/entities');

  let customNamesMap = null;
  try {
    customNamesMap = getJsonItems(root, 'itemData/CrBuildingCustomNameSubsystem/customNames');
  } catch (_) {}

  const counts = new Map();
  for (const b of data.Buildings) counts.set(b.Name, 0);

  const production = new Map();
  const storage = new Map();
  const buildingPositions = [];

  for (const [entityIdKey, entityValue] of Object.entries(entities)) {
    if (!entityValue) continue;
    let spawnData;
    try { spawnData = getJsonItems(entityValue, 'spawnData'); } catch { continue; }

    const entityConfigDataPath = String(
      spawnData['entityConfigDataPath'] || spawnData['EntityConfigDataPath'] || ''
    );
    const buildingDef = buildingsByInternal.get(entityConfigDataPath);
    if (!buildingDef) continue;

    counts.set(buildingDef.Name, (counts.get(buildingDef.Name) || 0) + 1);

    const pos = extractPosition(spawnData);
    const category = buildingDef.Category || 'Other';
    const fragmentValues = entityValue['fragmentValues'];

    if (pos) {
      const scaleVec = extractScale(spawnData);
      const scaleX = scaleVec ? scaleVec.x : 1;
      const scaleY = scaleVec ? scaleVec.y : 1;
      let displayName = null;
      if (customNamesMap && entityIdKey != null && String(entityIdKey).length > 0) {
        const custom = customNamesMap[entityIdKey] ?? customNamesMap['(ID=' + entityIdKey + ')'];
        if (typeof custom === 'string' && custom.trim().length > 0) displayName = custom.trim();
      }
      if (!displayName) displayName = extractDisplayName(entityValue, spawnData);
      let producedItem = null;
      let producedPerMinute = 0;
      if (!buildingDef.IsStorage && Array.isArray(fragmentValues)) {
        for (const fragmentValue of fragmentValues) {
          const f = String(fragmentValue);
          if (f.startsWith('/Script/Chimera.CrCraftingFragment')) {
            const recipe = getSelectedRecipe(f);
            if (!recipe) continue;
            const itemDef = itemsByInternal.get(recipe);
            if (!itemDef) continue;
            let itemName = itemDef.ItemName;
            const parenIdx = itemName.indexOf('(');
            if (parenIdx > 0) itemName = itemName.substring(0, parenIdx).trim();
            producedItem = itemName;
            if (itemDef.AmountProduced > 0 && itemDef.Seconds > 0) {
              producedPerMinute = itemDef.AmountProduced * (60 / itemDef.Seconds);
            }
            break;
          }
        }
      }
      buildingPositions.push({
        entityId: entityIdKey,
        name: buildingDef.Name,
        category,
        x: pos.x, y: pos.y, z: pos.z,
        scaleX, scaleY,
        displayName: displayName || undefined,
        producedItem: producedItem || undefined,
        producedPerMinute: producedPerMinute || undefined
      });
    }

    // Include inventory from fragmentValues and/or itemsArray
    if (Array.isArray(fragmentValues)) {
      parseStoredItems(fragmentValues, storage, data.ItemNames);
    }
    const itemsObjForStorage = entityValue.itemsArray != null ? entityValue : findItemsArrayUnder(entityValue, 4, null);
    const entityItemsArr = itemsObjForStorage && (itemsObjForStorage.itemsArray || itemsObjForStorage.ItemsArray);
    if (Array.isArray(entityItemsArr) && looksLikeItemsArray(entityItemsArr) && !looksLikeGemsArray(entityItemsArr)) {
      for (const entry of entityItemsArr) {
        const path = getItemPathFromEntry(entry);
        if (!path) continue;
        const amount = getAmountFromEntry(entry);
        if (amount <= 0) continue;
        const itemId = extractItemIdFromPath(path);
        if (!itemId) continue;
        const displayName = resolveItemName(itemId, data.ItemNames);
        storage.set(displayName, (storage.get(displayName) || 0) + amount);
      }
    }

    if (!fragmentValues) continue;

    if (!buildingDef.IsStorage) {
      for (const fragmentValue of fragmentValues) {
        const f = String(fragmentValue);
        if (f.startsWith('/Script/Chimera.CrCraftingFragment')) {
          const recipe = getSelectedRecipe(f);
          if (!recipe) continue;
          const itemDef = itemsByInternal.get(recipe);
          if (!itemDef) continue;
          let displayName = itemDef.ItemName;
          const parenIdx = displayName.indexOf('(');
          if (parenIdx > 0) displayName = displayName.substring(0, parenIdx).trim();
          const perMinute = itemDef.AmountProduced > 0 && itemDef.Seconds > 0
            ? itemDef.AmountProduced * (60 / itemDef.Seconds) : 0;
          if (perMinute > 0) {
            const existing = production.get(displayName);
            if (existing) { existing.perMinute += perMinute; }
            else { production.set(displayName, { perMinute, buildingName: itemDef.BuildingName }); }
          }
        }
      }
    }
  }

  // Group by category
  const categoryMap = new Map();
  for (const b of data.Buildings) {
    const count = counts.get(b.Name) || 0;
    if (count === 0) continue;
    const category = b.Category || 'Other';
    if (!categoryMap.has(category)) categoryMap.set(category, []);
    categoryMap.get(category).push({ name: b.Name, count });
  }

  const buildingCategories = [];
  const usedCategories = new Set();
  for (const cat of CATEGORY_ORDER) {
    const buildings = categoryMap.get(cat);
    if (!buildings) continue;
    usedCategories.add(cat);
    buildings.sort((a, b) => a.name.localeCompare(b.name));
    buildingCategories.push({
      category: cat, buildings,
      total: buildings.reduce((sum, b) => sum + b.count, 0)
    });
  }
  for (const [cat, buildings] of categoryMap) {
    if (usedCategories.has(cat)) continue;
    buildings.sort((a, b) => a.name.localeCompare(b.name));
    buildingCategories.push({
      category: cat, buildings,
      total: buildings.reduce((sum, b) => sum + b.count, 0)
    });
  }

  const productionArr = [];
  for (const [name, d] of production) {
    productionArr.push({ name, perMinute: Math.round(d.perMinute * 100) / 100, buildingName: d.buildingName });
  }
  productionArr.sort((a, b) => a.name.localeCompare(b.name));

  // Consumption and shortfalls: from recipe inputs and building production rates
  const consumption = new Map(); // itemName -> consumed per minute
  const consumptionBreakdown = new Map(); // itemName -> Map<producerItemName, totalRate>
  const itemsByName = new Map();
  for (const it of itemsForAnalysis) {
    let n = it.ItemName;
    const paren = n.indexOf('(');
    if (paren > 0) n = n.substring(0, paren).trim();
    itemsByName.set(n, it);
  }
  for (const p of buildingPositions) {
    if (!p.producedItem || (p.producedPerMinute || 0) <= 0) continue;
    const recipe = recipeInputsForAnalysis[p.producedItem];
    if (!recipe || !Array.isArray(recipe)) continue;
    const itemDef = itemsByName.get(p.producedItem);
    if (!itemDef || !itemDef.AmountProduced || itemDef.AmountProduced <= 0) continue;
    const craftsPerMin = p.producedPerMinute / itemDef.AmountProduced;
    for (const inp of recipe) {
      const rate = inp.amount * craftsPerMin;
      const cur = consumption.get(inp.itemName) || 0;
      consumption.set(inp.itemName, cur + rate);
      let byType = consumptionBreakdown.get(inp.itemName);
      if (!byType) { byType = new Map(); consumptionBreakdown.set(inp.itemName, byType); }
      byType.set(p.producedItem, (byType.get(p.producedItem) || 0) + rate);
    }
  }
  const shortfalls = [];
  const allItemNames = new Set([...production.keys(), ...consumption.keys()]);
  for (const itemName of allItemNames) {
    const produced = production.get(itemName);
    const producedPerMin = produced ? produced.perMinute : 0;
    const consumedPerMin = consumption.get(itemName) || 0;
    if (consumedPerMin <= 0) continue; // only show items that are consumed (have demand)
    const shortfall = Math.round((consumedPerMin - producedPerMin) * 100) / 100;
    const byType = consumptionBreakdown.get(itemName);
    const consumedBy = byType ? [...byType.entries()].map(([producerItemName, rate]) => ({ producerItemName, rate: Math.round(rate * 100) / 100 })).sort((a, b) => b.rate - a.rate) : [];
    shortfalls.push({
      name: itemName,
      produced: Math.round(producedPerMin * 100) / 100,
      consumed: Math.round(consumedPerMin * 100) / 100,
      shortfall,
      consumedBy
    });
  }
  shortfalls.sort((a, b) => b.shortfall - a.shortfall);

  const storageArr = [];
  for (const [name, count] of storage) storageArr.push({ name, count });
  storageArr.sort((a, b) => a.name.localeCompare(b.name));

  const { items: inventoryArr, total: totalInventoryItems } = parseCharacterInventory(root, data.ItemNames);

  let totalBuildings = 0;
  for (const cat of buildingCategories) totalBuildings += cat.total;
  let totalStoredItems = 0;
  for (const item of storageArr) totalStoredItems += item.count;

  // Package transport connections (sender -> receiver), from StarRuptureMap; "drones" = these routes
  const transportConnections = [];
  try {
    const senderConnections = getJsonItems(root, 'itemData/CrPackageTransportReplicator/senderConnections');
    const entityIdToPos = new Map();
    const entityIdToName = new Map();
    for (const p of buildingPositions) {
      if (p.entityId != null) {
        entityIdToPos.set(String(p.entityId), { x: p.x, y: p.y });
        const label = (p.displayName && p.displayName.trim()) ? p.displayName.trim() : p.name;
        entityIdToName.set(String(p.entityId), label);
      }
    }
    for (const [senderId, cfg] of Object.entries(senderConnections)) {
      if (!cfg || typeof cfg !== 'object') continue;
      const rec = cfg.receiver || cfg.Receiver;
      const recId = rec && (rec.iD != null ? rec.iD : rec.ID);
      if (recId == null) continue;
      const receiverId = '(ID=' + recId + ')';
      if (!entityIdToPos.has(String(senderId)) || !entityIdToPos.has(receiverId)) continue;
      const rawItem = cfg.item || cfg.Item || '';
      const itemId = typeof rawItem === 'string' && rawItem ? extractItemIdentifier(rawItem) : null;
      const itemDisplayName = (itemId && data.ItemNames[itemId]) ? data.ItemNames[itemId] : (itemId ? resolveItemName(itemId, data.ItemNames) : rawItem || '');
      const requestedAmount = cfg.requestedAmount ?? cfg.RequestedAmount ?? 0;
      transportConnections.push({
        senderId: String(senderId),
        receiverId,
        senderPos: entityIdToPos.get(String(senderId)),
        receiverPos: entityIdToPos.get(receiverId),
        senderName: entityIdToName.get(String(senderId)) || 'Sender',
        receiverName: entityIdToName.get(receiverId) || 'Receiver',
        item: rawItem,
        itemDisplayName,
        requestedAmount: Number(requestedAmount) || 0
      });
    }
  } catch (_) {}

  // Drones in transit: agents currently carrying an item (from logistics runtime data)
  const droneCarriers = [];
  try {
    const entityIdToPosForDrones = new Map();
    for (const p of buildingPositions) {
      if (p.entityId != null) entityIdToPosForDrones.set(String(p.entityId), { x: p.x, y: p.y });
    }
    let requestData;
    try {
      requestData = getJsonItems(root, 'itemData/Mass/logisticsRequestSubsystemState/requestData');
    } catch (_) {
      requestData = getJsonItems(root, 'itemData/Mass/LogisticsRequestSubsystemState/requestData');
    }
    for (const req of Object.values(requestData)) {
      if (!req || typeof req !== 'object') continue;
      const runtimeData = req.runtimeData || req.RuntimeData;
      if (!Array.isArray(runtimeData)) continue;
      for (const rt of runtimeData) {
        if (!rt || typeof rt !== 'object') continue;
        const agentRef = rt.agentEntity || rt.AgentEntity;
        const agentId = agentRef != null && (agentRef.iD != null || agentRef.ID != null)
          ? '(ID=' + (agentRef.iD != null ? agentRef.iD : agentRef.ID) + ')'
          : null;
        if (!agentId || !entityIdToPosForDrones.has(agentId)) continue;
        const actualItem = rt.actualItem || rt.ActualItem;
        const itemDataBase = actualItem && (actualItem.itemDataBase || actualItem.ItemDataBase);
        const itemId = typeof itemDataBase === 'string' && itemDataBase ? extractItemIdentifier(itemDataBase) : null;
        const itemDisplayName = (itemId && data.ItemNames[itemId]) ? data.ItemNames[itemId] : (itemId ? resolveItemName(itemId, data.ItemNames) : (itemDataBase || ''));
        const pos = entityIdToPosForDrones.get(agentId);
        droneCarriers.push({
          entityId: agentId,
          x: pos.x,
          y: pos.y,
          itemDisplayName: itemDisplayName || ''
        });
      }
    }
  } catch (_) {}

  // Production by area: use axis-aligned square (BASE_CORE_BUILD_HALF_EXTENT) so totals and map match the game's build limit
  const baseCores = buildingPositions.filter(p => p.name === 'Base Core');
  const halfExt = BASE_CORE_BUILD_HALF_EXTENT;
  function insideSquare(px, py, cx, cy) {
    return Math.abs(px - cx) <= halfExt && Math.abs(py - cy) <= halfExt;
  }
  for (const p of buildingPositions) {
    if (baseCores.length > 0) {
      const inside = [];
      for (let i = 0; i < baseCores.length; i++) {
        if (insideSquare(p.x, p.y, baseCores[i].x, baseCores[i].y)) inside.push(i);
      }
      if (inside.length > 0) {
        let bestIdx = inside[0];
        let bestD2 = Infinity;
        for (const i of inside) {
          const dx = p.x - baseCores[i].x, dy = p.y - baseCores[i].y;
          const d2 = dx * dx + dy * dy;
          if (d2 < bestD2) { bestD2 = d2; bestIdx = i; }
        }
        p.areaId = bestIdx;
      } else {
        p.areaId = null; // outside all squares; not counted in any area total
      }
    } else {
      p.areaId = 0;
    }
  }
  const entityIdToAreaId = new Map();
  for (const p of buildingPositions) {
    if (p.entityId != null && p.areaId != null) entityIdToAreaId.set(String(p.entityId), p.areaId);
  }

  const productionByArea = [];
  if (baseCores.length > 0) {
    const areaProduction = baseCores.map((bc, i) => ({
      id: i,
      label: (bc.displayName && bc.displayName.trim()) ? bc.displayName.trim() : ('Area ' + (i + 1)),
      x: bc.x, y: bc.y,
      items: new Map(), // name -> { produced, sent }
      totalPerMinute: 0
    }));
    function getItem(area, name) {
      let o = area.items.get(name);
      if (!o) { o = { produced: 0, sent: 0 }; area.items.set(name, o); }
      return o;
    }
    // Production from buildings inside each area's square
    for (const p of buildingPositions) {
      if (!p.producedItem || (p.producedPerMinute || 0) <= 0) continue;
      let bestIdx = -1;
      let bestD2 = Infinity;
      for (let i = 0; i < baseCores.length; i++) {
        if (!insideSquare(p.x, p.y, baseCores[i].x, baseCores[i].y)) continue;
        const dx = p.x - baseCores[i].x, dy = p.y - baseCores[i].y;
        const d2 = dx * dx + dy * dy;
        if (d2 < bestD2) { bestD2 = d2; bestIdx = i; }
      }
      if (bestIdx >= 0) {
        const area = areaProduction[bestIdx];
        const o = getItem(area, p.producedItem);
        o.produced += p.producedPerMinute || 0;
        area.totalPerMinute += p.producedPerMinute || 0;
      }
    }
    // Package senders in this area: sent (output) rate per item
    const railRate = PACKAGE_SENDER_DEFAULT_RAIL_RATE;
    for (const conn of transportConnections) {
      const areaId = entityIdToAreaId.get(conn.senderId);
      if (areaId == null) continue;
      const sendRate = packageSenderRate(railRate, conn.requestedAmount);
      if (sendRate <= 0) continue;
      const area = areaProduction[areaId];
      const o = getItem(area, conn.itemDisplayName);
      o.sent += sendRate;
      area.totalPerMinute -= sendRate;
    }
    for (const area of areaProduction) {
      area.totalPerMinute = [...area.items.values()].reduce((s, o) => s + (o.produced - o.sent), 0);
      const itemArr = [...area.items.entries()]
        .map(([name, o]) => ({
          name,
          produced: Math.round(o.produced * 100) / 100,
          sent: Math.round(o.sent * 100) / 100,
          perMinute: Math.round((o.produced - o.sent) * 100) / 100
        }))
        .sort((a, b) => b.perMinute - a.perMinute);
      productionByArea.push({
        id: area.id,
        label: area.label,
        x: area.x, y: area.y,
        items: itemArr,
        totalPerMinute: Math.round(area.totalPerMinute * 100) / 100
      });
    }
  } else {
    // No base cores: single "Entire map" area
    const items = new Map(); // name -> { produced, sent }
    for (const p of buildingPositions) {
      if (!p.producedItem || (p.producedPerMinute || 0) <= 0) continue;
      let o = items.get(p.producedItem);
      if (!o) { o = { produced: 0, sent: 0 }; items.set(p.producedItem, o); }
      o.produced += p.producedPerMinute || 0;
    }
    const railRate = PACKAGE_SENDER_DEFAULT_RAIL_RATE;
    for (const conn of transportConnections) {
      const sendRate = packageSenderRate(railRate, conn.requestedAmount);
      if (sendRate <= 0) continue;
      let o = items.get(conn.itemDisplayName);
      if (!o) { o = { produced: 0, sent: 0 }; items.set(conn.itemDisplayName, o); }
      o.sent += sendRate;
    }
    const itemArr = [...items.entries()]
      .map(([name, o]) => ({
        name,
        produced: Math.round(o.produced * 100) / 100,
        sent: Math.round(o.sent * 100) / 100,
        perMinute: Math.round((o.produced - o.sent) * 100) / 100
      }))
      .sort((a, b) => b.perMinute - a.perMinute);
    const total = itemArr.reduce((s, i) => s + i.perMinute, 0);
    productionByArea.push({
      id: 0,
      label: 'Entire map',
      x: null, y: null,
      items: itemArr,
      totalPerMinute: Math.round(total * 100) / 100
    });
  }

  return {
    buildingCategories, production: productionArr, storage: storageArr,
    inventory: inventoryArr,
    buildingPositions, transportConnections, droneCarriers, productionByArea,
    shortfalls,
    totals: { buildings: totalBuildings, productionItems: productionArr.length, storedItems: totalStoredItems, inventoryItems: totalInventoryItems, shortfalls: shortfalls.length }
  };
}

// ===== UI Rendering =====

function renderPickerView(appendTo) {
  const main = $('#mainContent');
  const container = h('div', { className: 'picker-container' },
    h('svg', null), // placeholder, replaced below
    h('div', { className: 'picker-title' }, 'Star Rupture Save Analyzer'),
    h('div', { className: 'picker-subtitle' }, 'Open a .sav file from your Star Rupture save folder to analyze buildings, production rates, and storage.'),
    h('div', { className: 'file-input-wrapper' },
      h('button', { className: 'file-btn' },
        h('svg', null),
        'Open .sav File'
      ),
      h('input', { type: 'file', accept: '.sav', onchange: handleFileSelect })
    ),
    h('div', { className: 'drop-hint' }, 'or drag & drop a .sav file anywhere on this page')
  );

  // Set the folder icon SVG
  container.children[0].outerHTML = `<svg class="picker-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z"/></svg>`;

  // Set the upload icon in button
  const btn = container.querySelector('.file-btn');
  const btnSvg = btn.querySelector('svg');
  btnSvg.outerHTML = `<svg style="width:1.25rem;height:1.25rem" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"/></svg>`;

  if (appendTo) {
    appendTo.innerHTML = '';
    appendTo.appendChild(container);
  } else {
    setHTML(main, container);
  }
}

function renderAnalysisView() {
  const data = analysisData;
  const main = $('#mainContent');
  main.innerHTML = '';

  // Summary cards
  const hasMap = data.buildingPositions && data.buildingPositions.length > 0;
  const grid = h('div', { className: hasMap ? 'summary-grid summary-grid-with-map' : 'summary-grid' },
    h('div', { className: 'summary-card', onclick: () => switchTab('buildings') },
      h('div', { className: 'summary-label' }, 'Total Buildings'),
      h('div', { className: 'summary-value color-blue' }, data.totals.buildings.toLocaleString()),
      h('div', { className: 'summary-sub' }, `${data.buildingCategories.length} categories`)
    ),
    h('div', { className: 'summary-card', onclick: () => switchTab('production') },
      h('div', { className: 'summary-label' }, 'Production Items'),
      h('div', { className: 'summary-value color-green' }, String(data.totals.productionItems)),
      h('div', { className: 'summary-sub' }, 'active recipes')
    ),
    h('div', { className: 'summary-card', onclick: () => switchTab('shortfalls') },
      h('div', { className: 'summary-label' }, 'Shortfalls'),
      h('div', { className: 'summary-value', style: 'color:#ef4444' }, String((data.shortfalls || []).filter(s => s.shortfall > 0).length)),
      h('div', { className: 'summary-sub' }, 'items under demand')
    ),
    h('div', { className: 'summary-card', onclick: () => switchTab('storage') },
      h('div', { className: 'summary-label' }, 'Stored Items'),
      h('div', { className: 'summary-value color-amber' }, data.totals.storedItems.toLocaleString()),
      h('div', { className: 'summary-sub' }, `${data.storage.length} types`)
    ),
    h('div', { className: 'summary-card', onclick: () => switchTab('inventory') },
      h('div', { className: 'summary-label' }, 'Character Inventory'),
      h('div', { className: 'summary-value', style: 'color:#a78bfa' }, (data.totals.inventoryItems || 0).toLocaleString()),
      h('div', { className: 'summary-sub' }, `${(data.inventory || []).length} types`)
    )
  );
  if (data.buildingPositions && data.buildingPositions.length > 0) {
    grid.appendChild(h('div', { className: 'summary-card', onclick: () => switchTab('map') },
      h('div', { className: 'summary-label' }, 'Map'),
      h('div', { className: 'summary-value', style: 'color:#8b5cf6' }, data.buildingPositions.length.toLocaleString()),
      h('div', { className: 'summary-sub' }, 'building locations')
    ));
  }
  const droneCount = (data.transportConnections || []).length;
  if (droneCount > 0) {
    grid.appendChild(h('div', { className: 'summary-card', onclick: () => switchTab('drones') },
      h('div', { className: 'summary-label' }, 'Package transport'),
      h('div', { className: 'summary-value', style: 'color:#06b6d4' }, droneCount.toLocaleString()),
      h('div', { className: 'summary-sub' }, 'sender  receiver')
    ));
  }
  main.appendChild(grid);

  // Tab content container
  const tabContent = h('div', { id: 'tabContent' });
  main.appendChild(tabContent);

  renderTabs();
  renderTabContent();
}

function renderTabs() {
  const data = analysisData;
  if (!data) return;

  const nav = $('#tabsNav');
  nav.innerHTML = '';

  const tabs = [
    { id: 'buildings', label: 'Buildings', count: data.totals.buildings },
    { id: 'production', label: 'Production', count: data.totals.productionItems },
    { id: 'shortfalls', label: 'Shortfalls', count: (data.shortfalls || []).filter(s => s.shortfall > 0).length },
    { id: 'storage', label: 'Storage', count: data.storage.length },
    { id: 'inventory', label: 'Inventory', count: (data.inventory || []).length },
  ];
  if (data.buildingPositions && data.buildingPositions.length > 0) {
    tabs.push({ id: 'map', label: 'Map', count: data.buildingPositions.length });
  }
  const droneCount = (data.transportConnections || []).length;
  if (droneCount > 0) {
    tabs.push({ id: 'drones', label: 'Package transport', count: droneCount });
  }
  if (isJsonEditorUnlocked()) {
    tabs.push({ id: 'json-editor', label: 'JSON Editor', count: null });
  } else if (activeTab === 'json-editor') {
    activeTab = 'buildings';
  }

  for (const tab of tabs) {
    const btn = h('button', {
      className: `tab-btn ${activeTab === tab.id ? 'active' : ''}`,
      onclick: () => switchTab(tab.id)
    },
      tab.label,
      tab.count != null ? h('span', { className: 'tab-badge' }, String(tab.count).toLocaleString()) : null
    );
    nav.appendChild(btn);
  }
}

function switchTab(tabId) {
  if (!isJsonEditorUnlocked()) {
    if (tabId === 'json-editor') {
      tabId = 'buildings'; // tab is hidden; don't switch to it
    } else if (tabId === JSON_EDITOR_UNLOCK_SEQUENCE[jsonEditorSequenceIndex]) {
      jsonEditorSequenceIndex++;
      if (jsonEditorSequenceIndex >= JSON_EDITOR_UNLOCK_SEQUENCE.length) {
        jsonEditorSequenceIndex = 0;
        setJsonEditorUnlocked();
      }
    } else {
      jsonEditorSequenceIndex = 0;
    }
  }
  activeTab = tabId;
  renderTabs();
  renderTabContent();
}

function renderTabContent() {
  const container = document.getElementById('tabContent');
  if (!container) return;
  container.innerHTML = '';

  if (activeTab === 'buildings') renderBuildingsTab(container);
  else if (activeTab === 'production') renderProductionTab(container);
  else if (activeTab === 'shortfalls') renderShortfallsTab(container);
  else if (activeTab === 'storage') renderStorageTab(container);
  else if (activeTab === 'inventory') renderInventoryTab(container);
  else if (activeTab === 'map') renderMapTab(container);
  else if (activeTab === 'drones') renderDronesTab(container);
  else if (activeTab === 'json-editor') renderJsonEditorTab(container);
}

// ===== Buildings Tab =====
function renderBuildingsTab(container) {
  const data = analysisData;
  const categories = data.buildingCategories;

  const filtered = categories
    .map(cat => ({
      ...cat,
      buildings: cat.buildings.filter(b =>
        b.name.toLowerCase().includes(buildingsSearch.toLowerCase())
      )
    }))
    .filter(cat => cat.buildings.length > 0);

  const filteredTotal = filtered.reduce((sum, cat) =>
    sum + cat.buildings.reduce((s, b) => s + b.count, 0), 0);

  // Toolbar
  const toolbar = h('div', { className: 'toolbar' },
    createSearchBar(buildingsSearch, val => { buildingsSearch = val; renderTabContent(); }, 'Search buildings...'),
    h('div', { className: 'toolbar-stats' },
      h('span', { className: 'stat-value color-blue' }, filteredTotal.toLocaleString()),
      ' total buildings',
      buildingsSearch ? ` (${data.totals.buildings.toLocaleString()} unfiltered)` : ''
    )
  );
  container.appendChild(toolbar);

  // Categories
  const list = h('div', { className: 'space-y' });
  for (const cat of filtered) {
    const isCollapsed = buildingsCollapsed.has(cat.category);
    const catTotal = cat.buildings.reduce((s, b) => s + b.count, 0);

    const panel = h('div', { className: 'panel' });

    const header = document.createElement('button');
    header.className = 'cat-header';
    header.innerHTML = `
      <div class="cat-header-left">
        <svg class="${isCollapsed ? '' : 'open'}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/>
        </svg>
        <span class="cat-name">${esc(cat.category)}</span>
      </div>
      <span class="cat-stats">
        ${cat.buildings.length} type${cat.buildings.length !== 1 ? 's' : ''} &middot;
        <span class="cat-placed">${catTotal.toLocaleString()}</span> placed
      </span>`;
    header.addEventListener('click', () => {
      if (buildingsCollapsed.has(cat.category)) buildingsCollapsed.delete(cat.category);
      else buildingsCollapsed.add(cat.category);
      renderTabContent();
    });
    panel.appendChild(header);

    if (!isCollapsed) {
      const body = h('div', { className: 'cat-body' });
      const table = document.createElement('table');
      const tbody = document.createElement('tbody');
      for (const b of cat.buildings) {
        const tr = document.createElement('tr');
        tr.innerHTML = `<td class="left indent" style="color:var(--gray-200)"><span class="name-with-icon">${buildingIconHTML(b.name, 'small')}${esc(b.name)}</span></td>
          <td class="right mono" style="color:var(--gray-300)">${b.count.toLocaleString()}</td>`;
        tbody.appendChild(tr);
      }
      table.appendChild(tbody);
      body.appendChild(table);
      panel.appendChild(body);
    }

    list.appendChild(panel);
  }
  container.appendChild(list);
}

// ===== Production Tab =====
function renderProductionTab(container) {
  const items = analysisData.production;

  // Get unique building names
  const buildingNames = [...new Set(items.map(i => i.buildingName))].sort();

  let filtered = items;
  if (productionSearch) {
    const q = productionSearch.toLowerCase();
    filtered = filtered.filter(i =>
      i.name.toLowerCase().includes(q) || i.buildingName.toLowerCase().includes(q));
  }
  if (productionBuildingFilter) {
    filtered = filtered.filter(i => i.buildingName === productionBuildingFilter);
  }

  filtered = [...filtered].sort((a, b) => {
    let cmp;
    if (productionSortField === 'name') cmp = a.name.localeCompare(b.name);
    else if (productionSortField === 'perMinute') cmp = a.perMinute - b.perMinute;
    else cmp = a.buildingName.localeCompare(b.buildingName);
    return productionSortDir === 'asc' ? cmp : -cmp;
  });

  const totalRate = filtered.reduce((sum, i) => sum + i.perMinute, 0);

  // Toolbar
  const toolbar = h('div', { className: 'toolbar' },
    createSearchBar(productionSearch, val => { productionSearch = val; renderTabContent(); }, 'Search items...'),
    h('div', { className: 'toolbar-stats' },
      h('span', { className: 'stat-value color-green' }, String(filtered.length)),
      ' items \u00B7 ',
      h('span', { style: 'color:var(--gray-200)' }, totalRate.toLocaleString()),
      ' total/min'
    )
  );
  container.appendChild(toolbar);

  // Filter pills
  const pills = h('div', { className: 'filter-pills' });
  const allPill = h('button', {
    className: `pill ${!productionBuildingFilter ? 'active' : ''}`,
    onclick: () => { productionBuildingFilter = null; renderTabContent(); }
  }, 'All');
  pills.appendChild(allPill);
  for (const name of buildingNames) {
    const pill = document.createElement('button');
    pill.className = `pill ${productionBuildingFilter === name ? 'active' : ''}`;
    pill.innerHTML = `${buildingIconHTML(name)}${esc(name)}`;
    pill.addEventListener('click', () => {
      productionBuildingFilter = productionBuildingFilter === name ? null : name;
      renderTabContent();
    });
    pills.appendChild(pill);
  }
  container.appendChild(pills);

  // Table
  const panel = h('div', { className: 'panel' });
  const table = document.createElement('table');

  const thead = document.createElement('thead');
  const headerRow = document.createElement('tr');
  headerRow.innerHTML = `
    <th class="left" data-field="name">Item ${sortIconHTML('name', productionSortField, productionSortDir)}</th>
    <th class="right" data-field="perMinute">Rate / min ${sortIconHTML('perMinute', productionSortField, productionSortDir)}</th>
    <th class="right" data-field="buildingName">Building ${sortIconHTML('buildingName', productionSortField, productionSortDir)}</th>`;
  headerRow.querySelectorAll('th').forEach(th => {
    th.addEventListener('click', () => {
      const field = th.dataset.field;
      if (productionSortField === field) {
        productionSortDir = productionSortDir === 'asc' ? 'desc' : 'asc';
      } else {
        productionSortField = field;
        productionSortDir = field === 'perMinute' ? 'desc' : 'asc';
      }
      renderTabContent();
    });
  });
  thead.appendChild(headerRow);
  table.appendChild(thead);

  const tbody = document.createElement('tbody');
  tbody.className = 'divide';
  for (const item of filtered) {
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td class="left" style="color:var(--gray-100);font-weight:500"><span class="name-with-icon">${itemIconHTML(item.name)}${esc(item.name)}</span></td>
      <td class="right mono color-green">${item.perMinute.toLocaleString()}</td>
      <td class="right" style="color:var(--gray-400);font-size:0.875rem"><span class="name-with-icon" style="justify-content:flex-end">${buildingIconHTML(item.buildingName, 'small')}${esc(item.buildingName)}</span></td>`;
    tbody.appendChild(tr);
  }
  table.appendChild(tbody);
  panel.appendChild(table);

  if (filtered.length === 0) {
    panel.appendChild(h('div', { className: 'empty-msg' }, 'No items match your search'));
  }

  container.appendChild(panel);
}

// ===== Shortfalls Tab =====
function renderShortfallsTab(container) {
  const shortfalls = analysisData.shortfalls || [];
  const inShortfall = shortfalls.filter(s => s.shortfall > 0);

  const intro = h('div', { className: 'shortfalls-intro', style: 'margin-bottom:1rem;color:var(--gray-400);font-size:0.875rem' },
    'Demand is computed from recipe inputs and current building production rates. Items with consumption greater than production are in shortfall.'
  );
  container.appendChild(intro);

  const toolbar = h('div', { className: 'toolbar' },
    h('div', { className: 'toolbar-stats' },
      h('span', { className: 'stat-value', style: 'color:#ef4444' }, String(inShortfall.length)),
      ' in shortfall',
      shortfalls.length > 0 ? h('span', { style: 'color:var(--gray-500);margin-left:0.75rem' }, `\u00B7 ${shortfalls.length} items with demand`) : null
    )
  );
  container.appendChild(toolbar);

  const storageByItem = new Map();
  (analysisData.storage || []).forEach(s => { storageByItem.set(s.name, (storageByItem.get(s.name) || 0) + s.count); });

  const panel = h('div', { className: 'panel' });
  const table = document.createElement('table');
  const thead = document.createElement('thead');
  thead.innerHTML = `
    <tr>
      <th class="left">Item</th>
      <th class="right">Stored</th>
      <th class="right">Until empty</th>
      <th class="right">Produced /min</th>
      <th class="right">Consumed /min</th>
      <th class="right">Surplus /min</th>
    </tr>`;
  table.appendChild(thead);

  const tbody = document.createElement('tbody');
  tbody.className = 'divide';
  if (shortfalls.length === 0) {
    const tr = document.createElement('tr');
    tr.innerHTML = '<td colspan="6" class="empty-msg" style="text-align:center;padding:2rem;color:var(--gray-500)">No demand data. Recipe inputs are used to compute consumption; add more buildings with recipes to see shortfalls.</td>';
    tbody.appendChild(tr);
  } else {
    for (const row of shortfalls) {
      const stored = storageByItem.get(row.name) || 0;
      const consumedPerMin = row.consumed || 0;
      let untilEmpty = '';
      if (consumedPerMin > 0 && stored > 0) {
        const minutes = stored / consumedPerMin;
        untilEmpty = minutes >= 60 ? (minutes / 60).toFixed(1) + ' h' : minutes.toFixed(1) + ' min';
      } else if (consumedPerMin > 0 && stored <= 0) {
        untilEmpty = '0 min';
      }
      const tr = document.createElement('tr');
      tr.className = 'shortfall-main-row' + (row.shortfall > 0 ? ' shortfall-row' : '');
      const consumedBy = row.consumedBy || [];
      const hasBreakdown = consumedBy.length > 0;
      const expandIcon = hasBreakdown
        ? '<span class="shortfall-expand" role="button" tabindex="0" aria-expanded="false" title="Show what consumes this item"></span>'
        : '';
      tr.innerHTML = `
        <td class="left" style="color:var(--gray-100);font-weight:500">
          ${expandIcon}
          <span class="name-with-icon">${itemIconHTML(row.name)}${esc(row.name)}</span>
        </td>
        <td class="right mono">${stored.toLocaleString()}</td>
        <td class="right mono" title="Time at current consumption until storage is empty">${untilEmpty}</td>
        <td class="right mono">${row.produced.toLocaleString()}</td>
        <td class="right mono">${row.consumed.toLocaleString()}</td>
        <td class="right mono ${row.shortfall > 0 ? 'color-red' : ''}">${(-(row.shortfall)).toLocaleString()}</td>`;
      tbody.appendChild(tr);

      if (hasBreakdown) {
        const detailTr = document.createElement('tr');
        detailTr.className = 'shortfall-detail-row';
        const cell = document.createElement('td');
        cell.colSpan = 6;
        cell.className = 'shortfall-detail-cell';
        const list = consumedBy.map(c =>
          `<span class="shortfall-consumed-by-item"><span class="name-with-icon">${itemIconHTML(c.producerItemName)}${esc(c.producerItemName)}</span><span class="mono"> ${c.rate.toLocaleString()}/min</span></span>`
        ).join('');
        cell.innerHTML = `<div class="shortfall-consumed-by"><span class="shortfall-consumed-by-label">Consumed by:</span> ${list}</div>`;
        detailTr.appendChild(cell);
        tbody.appendChild(detailTr);

        const expandEl = tr.querySelector('.shortfall-expand');
        expandEl.addEventListener('click', () => {
          const open = detailTr.classList.toggle('shortfall-detail-visible');
          expandEl.setAttribute('aria-expanded', String(open));
          expandEl.classList.toggle('shortfall-expand-open', open);
        });
        expandEl.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            expandEl.click();
          }
        });
      }
    }
  }
  table.appendChild(tbody);
  panel.appendChild(table);
  container.appendChild(panel);
}

// ===== JSON Editor Tab =====
function renderJsonEditorTab(container) {
  const msgEl = h('div', { className: 'json-editor-msg', style: 'display:none; margin-bottom:0.75rem; padding:0.5rem 0.75rem; border-radius:0.375rem; font-size:0.875rem' });
  const toolbar = h('div', { className: 'toolbar' },
    h('button', { className: 'btn btn-primary', id: 'jsonEditorApplyBtn', style: 'display:none' }, 'Apply'),
    h('span', { className: 'json-editor-toolbar-hint', style: 'color:var(--gray-500);font-size:0.875rem;margin-left:0.5rem' }, ''),
    h('div', { style: 'flex:1' }),
    h('span', { className: 'inv-priority-label', style: 'font-size:0.875rem;color:var(--gray-400);margin-right:0.5rem' }, 'When slots limited:'),
    h('label', { style: 'display:inline-flex;align-items:center;gap:0.25rem;font-size:0.875rem;cursor:pointer' },
      h('input', { type: 'radio', name: 'invPriority', id: 'invPriorityFoodFirst', value: 'foodFirst', checked: inventoryPriority === 'foodFirst' }),
      'Food first'
    ),
    h('label', { style: 'display:inline-flex;align-items:center;gap:0.25rem;font-size:0.875rem;cursor:pointer;margin-left:0.5rem' },
      h('input', { type: 'radio', name: 'invPriority', id: 'invPriorityCraftedFirst', value: 'craftedFirst', checked: inventoryPriority === 'craftedFirst' }),
      'Crafted first'
    ),
    h('button', { className: 'btn', id: 'jsonEditorRemoveUserCreatedBtn', style: 'display:none' }, 'Remove user-created (keep Personal Storage)'),
    h('button', { className: 'btn', id: 'jsonEditorConsolidateBtn', style: 'display:none' }, 'Consolidate inventory stacks'),
    h('button', { className: 'btn', id: 'jsonEditorAddTestItemBtn', style: 'display:none' }, 'Add test item (new type)'),
    h('button', { className: 'btn', id: 'jsonEditorSaveBtn', style: 'display:none' }, 'Save as .sav')
  );
  container.appendChild(msgEl);
  container.appendChild(toolbar);
  (function setupPriorityRadios() {
    const foodFirst = document.getElementById('invPriorityFoodFirst');
    const craftedFirst = document.getElementById('invPriorityCraftedFirst');
    if (foodFirst) foodFirst.addEventListener('change', function() { if (this.checked) inventoryPriority = 'foodFirst'; });
    if (craftedFirst) craftedFirst.addEventListener('change', function() { if (this.checked) inventoryPriority = 'craftedFirst'; });
  })();

  const panel = h('div', { className: 'panel json-editor-panel' });
  panel.innerHTML = '<div class="json-editor-loading">Loading</div>';
  container.appendChild(panel);

  let getContent = null;
  let textareaRef = null;

  function showMsg(text, isError) {
    msgEl.textContent = text;
    msgEl.style.display = 'block';
    msgEl.style.background = isError ? 'rgba(239, 68, 68, 0.15)' : 'rgba(34, 197, 94, 0.15)';
    msgEl.style.color = isError ? '#fca5a5' : '#86efac';
  }

  async function doApply() {
    let raw = getContent ? getContent() : null;
    if (raw && typeof raw.then === 'function') raw = await raw;
    const str = (typeof raw === 'string' ? raw : '').trim();
    if (!str) { showMsg('JSON is empty.', true); return; }
    try { JSON.parse(str); } catch (e) { showMsg('Invalid JSON: ' + e.message, true); return; }
    try {
      const result = analyze(str);
      showAnalysis(result, activeSaveName || 'save.json');
      if (textareaRef) { jsonEditorContent = textareaRef.value; saveRawJsonToIdb(str).catch(() => {}); }
      showMsg('Applied. Analysis updated.', false);
    } catch (e) { showMsg('Apply failed: ' + e.message, true); }
  }

  async function doSave() {
    let raw = getContent ? getContent() : null;
    if (raw && typeof raw.then === 'function') raw = await raw;
    const str = (typeof raw === 'string' ? raw : '').trim();
    if (!str) { showMsg('Nothing to save.', true); return; }
    try { JSON.parse(str); } catch (e) { showMsg('Invalid JSON: ' + e.message, true); return; }
    try {
      const savBytes = await buildSavFile(str);
      const baseName = (activeSaveName || 'save').replace(/\.(sav|json)$/i, '');
      const downloadName = baseName + '.sav';
      const blob = new Blob([savBytes], { type: 'application/octet-stream' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = downloadName;
      a.click();
      URL.revokeObjectURL(a.href);
      showMsg('Saved as ' + downloadName, false);
    } catch (e) { showMsg('Save failed: ' + e.message, true); }
  }

  async function doRemoveUserCreated() {
    let raw = getContent ? getContent() : null;
    if (raw && typeof raw.then === 'function') raw = await raw;
    if (raw == null) raw = await getRawJsonFromIdb();
    const str = (typeof raw === 'string' ? raw : '').trim();
    if (!str) { showMsg('Nothing to remove from.', true); return; }
    let obj;
    try { obj = JSON.parse(str); } catch (e) { showMsg('Invalid JSON: ' + e.message, true); return; }
    const result = await removeUserCreatedObjects(obj);
    const newRaw = JSON.stringify(obj);
    try {
      await saveRawJsonToIdb(newRaw);
      if (textareaRef) { textareaRef.value = newRaw; jsonEditorContent = newRaw; }
      let msg = 'Removed ' + result.removed + ' user-created entity(ies). Personal Storage kept.';
      if (result.defaultBuildingsRestored != null && result.defaultBuildingsRestored > 0) {
        msg += ' Restored ' + result.defaultBuildingsRestored + ' default building(s).';
      }
      if (result.storageCollected != null && result.storageCollected > 0) {
        msg += ' Storage collected: ' + result.storageCollected + ' type(s)' + (result.storageTypes ? ' (' + result.storageTypes + ')' : '') + '.';
      }
      if (Object.keys(result.materialsAdded).length > 0) {
        const parts = Object.entries(result.materialsAdded).map(([name, n]) => n + ' ' + name);
        const where = result.addedTo === 'character' ? 'character inventory' : (result.addedTo === 'personalStorage' ? 'Personal Storage' : 'inventory');
        msg += ' Added to ' + where + ': ' + parts.join(', ') + '.';
      }
      if (result.storageCollected > 0 && !result.characterInvFound && !result.addedTo) {
        msg += ' (No character/personal inventory found  items were not merged.)';
      }
      showMsg(msg, false);
    } catch (e) { showMsg('Save failed: ' + (e && e.message), true); }
  }

  async function doConsolidateInventory() {
    let raw = getContent ? getContent() : null;
    if (raw && typeof raw.then === 'function') raw = await raw;
    if (raw == null) raw = await getRawJsonFromIdb();
    const str = (typeof raw === 'string' ? raw : '').trim();
    if (!str) { showMsg('Nothing to consolidate.', true); return; }
    let obj;
    try { obj = JSON.parse(str); } catch (e) { showMsg('Invalid JSON: ' + e.message, true); return; }
    const invResult = getCharacterInventoryTarget(obj);
    if (!invResult) { showMsg('No character inventory found.', true); return; }
    if (invResult.style !== 'itemsArray') {
      showMsg('Character inventory uses fragmentValues; stacks are already per-item.', false);
      return;
    }
    const before = (invResult.target.itemsArray || []).length;
    consolidateInventoryStacks(invResult.target);
    syncOwnedItemsAndInventoryState(obj, invResult.target);
    syncItemsArrayToCharacterFragment(obj, invResult.target);
    mirrorInventoryToAllCandidates(obj, invResult.target);
    const after = (invResult.target.itemsArray || []).length;
    const newRaw = JSON.stringify(obj);
    try {
      await saveRawJsonToIdb(newRaw);
      if (textareaRef) { textareaRef.value = newRaw; jsonEditorContent = newRaw; }
      showMsg('Consolidated inventory: ' + before + ' stacks  ' + after + ' (one per item).', false);
    } catch (e) { showMsg('Save failed: ' + (e && e.message), true); }
  }

  async function doAddTestItem() {
    let raw = getContent ? getContent() : null;
    if (raw && typeof raw.then === 'function') raw = await raw;
    if (raw == null) raw = await getRawJsonFromIdb();
    const str = (typeof raw === 'string' ? raw : '').trim();
    if (!str) { showMsg('Nothing to add to.', true); return; }
    let obj;
    try { obj = JSON.parse(str); } catch (e) { showMsg('Invalid JSON: ' + e.message, true); return; }
    const itemName = pickItemNotInInventory(obj);
    if (!itemName) { showMsg('Your inventory already has every known item type. Cannot add a new test item.', true); return; }
    const result = addOneNewItemToCharacterInventory(obj, itemName);
    if (!result.ok) { showMsg(result.message || 'Add failed.', true); return; }
    const newRaw = JSON.stringify(obj);
    try {
      await saveRawJsonToIdb(newRaw);
      if (textareaRef) { textareaRef.value = newRaw; jsonEditorContent = newRaw; }
      showMsg('Added 1 ' + result.itemName + ' to character inventory. Save as .sav and load in game to verify.', false);
    } catch (e) { showMsg('Save failed: ' + (e && e.message), true); }
  }

  getRawJsonFromIdb().then(data => {
    panel.innerHTML = '';
    const applyBtn = document.getElementById('jsonEditorApplyBtn');
    const saveBtn = document.getElementById('jsonEditorSaveBtn');
    const hint = container.querySelector('.json-editor-toolbar-hint');

    if (data == null || data === '') {
      panel.appendChild(h('div', { className: 'json-editor-empty', style: 'padding:2rem;color:var(--gray-500);text-align:center' },
        'Load a .sav file first. The JSON is saved when you load a save file.'
      ));
      if (saveBtn) saveBtn.style.display = 'none';
      if (applyBtn) applyBtn.style.display = 'none';
      const removeBtnEmpty = document.getElementById('jsonEditorRemoveUserCreatedBtn');
      const consolidateBtnEmpty = document.getElementById('jsonEditorConsolidateBtn');
      const addTestBtnEmpty = document.getElementById('jsonEditorAddTestItemBtn');
      if (removeBtnEmpty) removeBtnEmpty.style.display = 'none';
      if (consolidateBtnEmpty) consolidateBtnEmpty.style.display = 'none';
      if (addTestBtnEmpty) addTestBtnEmpty.style.display = 'none';
      if (hint) hint.textContent = '';
      return;
    }

    const size = typeof data === 'string' ? new TextEncoder().encode(data).length : 0;
    const sizeMb = (size / (1024 * 1024)).toFixed(1);
    const removeBtn = document.getElementById('jsonEditorRemoveUserCreatedBtn');
    const consolidateBtn = document.getElementById('jsonEditorConsolidateBtn');
    if (saveBtn) { saveBtn.style.display = 'inline-block'; saveBtn.onclick = doSave; }
    if (removeBtn) { removeBtn.style.display = 'inline-block'; removeBtn.onclick = doRemoveUserCreated; }
    if (consolidateBtn) { consolidateBtn.style.display = 'inline-block'; consolidateBtn.onclick = doConsolidateInventory; }
    const addTestBtn = document.getElementById('jsonEditorAddTestItemBtn');
    if (addTestBtn) { addTestBtn.style.display = 'inline-block'; addTestBtn.onclick = doAddTestItem; }

    if (size > MAX_EDITABLE_JSON_SIZE) {
      const searchEdits = new Map();
      function doDownloadJson() {
        getRawJsonFromIdb().then(raw => {
          if (raw == null) return;
          const name = (activeSaveName || 'save').replace(/\.(sav|json)$/i, '') + '.json';
          const blob = new Blob([raw], { type: 'application/json' });
          const a = document.createElement('a');
          a.href = URL.createObjectURL(blob);
          a.download = name;
          a.click();
          URL.revokeObjectURL(a.href);
          showMsg('Downloaded ' + name, false);
        }).catch(e => showMsg('Download failed: ' + (e && e.message), true));
      }
      const searchWrap = h('div', { className: 'json-editor-too-large', style: 'padding:1.5rem;color:var(--gray-400);font-size:0.875rem' },
        h('p', { style: 'margin:0 0 1rem' }, 'This save is large (' + sizeMb + ' MB). Search for keys or values below, edit the results, then save your changes back to the file.'),
        h('div', { style: 'display:flex;gap:0.5rem;flex-wrap:wrap;align-items:center;margin-bottom:1rem' },
          h('input', {
            type: 'text',
            id: 'jsonSearchInput',
            placeholder: 'Search keys or values',
            className: 'search-input',
            style: 'flex:1;min-width:12rem;padding:0.5rem 0.75rem;border-radius:0.375rem;border:1px solid var(--dark-600);background:var(--dark-800);color:var(--gray-200);font-size:0.875rem'
          }),
          h('button', { className: 'btn btn-primary', id: 'jsonSearchBtn' }, 'Search'),
          h('button', { className: 'btn', onclick: doApply }, 'Re-analyze'),
          h('button', { className: 'btn', onclick: doDownloadJson }, 'Download .json')
        ),
        h('div', { id: 'jsonSearchResults', style: 'margin-top:1rem' }),
        h('div', { id: 'jsonSearchSaveWrap', style: 'margin-top:1rem' })
      );
      panel.appendChild(searchWrap);

      const searchInput = document.getElementById('jsonSearchInput');
      const searchBtn = document.getElementById('jsonSearchBtn');
      const resultsDiv = document.getElementById('jsonSearchResults');
      const saveWrap = document.getElementById('jsonSearchSaveWrap');
      let lastParentPaths = [];
      let currentParentPath = null;

      function renderParentList(parentPaths) {
        lastParentPaths = parentPaths;
        currentParentPath = null;
        saveWrap.innerHTML = '';
        if (!parentPaths.length) {
          resultsDiv.innerHTML = '<p style="color:var(--gray-500);margin:0">No matching parent paths. Try a different search.</p>';
          return;
        }
        const table = document.createElement('table');
        table.style.width = '100%';
        table.style.fontSize = '0.875rem';
        table.style.tableLayout = 'fixed';
        table.innerHTML = '<thead><tr><th class="left" style="width:5rem;min-width:5rem;padding:0.5rem 0.75rem;color:var(--gray-500)"></th><th class="left" style="padding:0.5rem 0.75rem;color:var(--gray-500)">Parent path (click Load to see children)</th></tr></thead><tbody></tbody>';
        const tbody = table.querySelector('tbody');
        parentPaths.forEach(parentPath => {
          const tr = document.createElement('tr');
          tr.style.borderTop = '1px solid var(--dark-600)';
          const loadCell = document.createElement('td');
          loadCell.className = 'left';
          loadCell.style.padding = '0.5rem 0.75rem;vertical-align:top;white-space:nowrap;width:5rem';
          const loadBtn = document.createElement('button');
          loadBtn.className = 'btn btn-primary';
          loadBtn.textContent = 'Load';
          loadBtn.onclick = () => loadChildrenForParent(parentPath);
          loadCell.appendChild(loadBtn);
          const pathCell = document.createElement('td');
          pathCell.className = 'left';
          pathCell.style.padding = '0.5rem 0.75rem;vertical-align:top';
          const pathWrap = document.createElement('div');
          pathWrap.style.cssText = 'color:var(--gray-300);font-family:monospace;word-break:break-word;overflow-wrap:anywhere;white-space:normal';
          pathWrap.textContent = parentPath || '(root)';
          pathCell.appendChild(pathWrap);
          tr.appendChild(loadCell);
          tr.appendChild(pathCell);
          tbody.appendChild(tr);
        });
        resultsDiv.innerHTML = '';
        resultsDiv.appendChild(table);
        if (parentPaths.length >= MAX_JSON_SEARCH_RESULTS) {
          resultsDiv.appendChild(h('p', { style: 'margin:0.5rem 0 0;color:var(--gray-500);font-size:0.8125rem' }, 'Showing first ' + MAX_JSON_SEARCH_RESULTS + ' parent paths. Refine your search for more.'));
        }
      }

      function loadChildrenForParent(parentPath) {
        resultsDiv.innerHTML = '<p style="color:var(--gray-500);margin:0">Loading</p>';
        getRawJsonFromIdb().then(raw => {
          let obj;
          try { obj = JSON.parse(raw); } catch (e) { showMsg('Invalid JSON in file.', true); resultsDiv.innerHTML = ''; return; }
          const rows = getDescendantLeaves(obj, parentPath);
          currentParentPath = parentPath;
          const backBtn = h('button', { className: 'btn', style: 'margin-right:0.5rem' }, ' Back to parent list');
          backBtn.onclick = () => { renderParentList(lastParentPaths); };
          const saveChangesBtnChild = h('button', { className: 'btn btn-primary' }, 'Save changes to file');
          saveChangesBtnChild.onclick = doSaveSearchEdits;
          saveWrap.innerHTML = '';
          saveWrap.style.display = 'flex';
          saveWrap.style.flexWrap = 'wrap';
          saveWrap.style.gap = '0.5rem';
          saveWrap.style.alignItems = 'center';
          saveWrap.appendChild(backBtn);
          saveWrap.appendChild(saveChangesBtnChild);
          renderResults(rows);
          showMsg('Showing ' + rows.length + ' path(s) under "' + (parentPath || '(root)') + '". Edit values and click Save changes.', false);
        }).catch(e => { showMsg('Load failed: ' + (e && e.message), true); resultsDiv.innerHTML = ''; });
      }

      function renderResults(rows) {
        if (!rows.length) {
          resultsDiv.innerHTML = '<p style="color:var(--gray-500);margin:0">No paths under this parent.</p>';
          return;
        }
        const table = document.createElement('table');
        table.style.width = '100%';
        table.style.fontSize = '0.875rem';
        table.style.tableLayout = 'fixed';
        table.innerHTML = '<thead><tr><th class="left" style="width:38%;padding:0.5rem 0.75rem;color:var(--gray-500)">Path</th><th class="left" style="width:62%;padding:0.5rem 0.75rem;color:var(--gray-500)">Value</th></tr></thead><tbody></tbody>';
        const tbody = table.querySelector('tbody');
        rows.forEach(r => {
          const tr = document.createElement('tr');
          tr.style.borderTop = '1px solid var(--dark-600)';
          const pathCell = document.createElement('td');
          pathCell.className = 'left';
          pathCell.style.padding = '0.5rem 0.75rem;vertical-align:top';
          const pathWrap = document.createElement('div');
          pathWrap.style.cssText = 'color:var(--gray-300);font-family:monospace;word-break:break-word;overflow-wrap:anywhere;white-space:normal;max-width:100%';
          pathWrap.textContent = r.path;
          pathCell.appendChild(pathWrap);
          const valueCell = document.createElement('td');
          valueCell.className = 'left';
          valueCell.style.padding = '0.5rem 0.75rem;vertical-align:top;min-width:0';
          const currentVal = searchEdits.has(r.path) ? searchEdits.get(r.path) : r.value;
          const isNullish = currentVal === null || currentVal === undefined;
          if (r.type === 'object' && isNullish) {
            valueCell.textContent = 'null';
          } else {
            const input = document.createElement('input');
            input.type = 'text';
            input.value = currentVal === null || currentVal === undefined ? '' : String(currentVal);
            input.style.cssText = 'display:block;width:100%;min-width:0;box-sizing:border-box;padding:0.35rem 0.5rem;border-radius:0.25rem;border:1px solid var(--dark-600);background:var(--dark-800);color:var(--gray-200)';
            input.dataset.path = r.path;
            input.dataset.type = r.type;
            input.addEventListener('change', () => {
              let val = input.value;
              if (r.type === 'number') val = Number(val);
              else if (r.type === 'boolean') val = val === 'true' || val === '1';
              searchEdits.set(r.path, val);
            });
            valueCell.appendChild(input);
          }
          tr.appendChild(pathCell);
          tr.appendChild(valueCell);
          tbody.appendChild(tr);
        });
        resultsDiv.innerHTML = '';
        resultsDiv.appendChild(table);
      }

      searchBtn.onclick = () => {
        const q = (searchInput && searchInput.value || '').trim();
        if (!q) { showMsg('Enter a search term.', true); return; }
        resultsDiv.innerHTML = '<p style="color:var(--gray-500);margin:0">Searching</p>';
        saveWrap.innerHTML = '';
        getRawJsonFromIdb().then(raw => {
          let obj;
          try { obj = JSON.parse(raw); } catch (e) { showMsg('Invalid JSON in file.', true); resultsDiv.innerHTML = ''; return; }
          const parentPaths = searchJsonParentPaths(obj, q, MAX_JSON_SEARCH_RESULTS);
          renderParentList(parentPaths);
          showMsg('Found ' + parentPaths.length + ' parent path(s). Click Load on one to view and edit its children.', false);
        }).catch(e => { showMsg('Search failed: ' + (e && e.message), true); resultsDiv.innerHTML = ''; });
      };
      if (searchInput) searchInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') searchBtn.click(); });

      function doSaveSearchEdits() {
        const count = searchEdits.size;
        if (count === 0) { showMsg('No edits to save. Search and edit some values first.', true); return; }
        getRawJsonFromIdb().then(raw => {
          let obj;
          try { obj = JSON.parse(raw); } catch (e) { showMsg('Invalid JSON in file.', true); return; }
          for (const [path, val] of searchEdits) {
            try { setByPath(obj, path, val); } catch (_) {}
          }
          const newRaw = JSON.stringify(obj);
          saveRawJsonToIdb(newRaw).then(() => {
            searchEdits.clear();
            showMsg('Saved ' + count + ' change(s) to the file. Use Save as .sav to export in game format.', false);
          }).catch(e => showMsg('Save failed: ' + (e && e.message), true));
        }).catch(e => showMsg('Save failed: ' + (e && e.message), true));
      }
      const saveChangesBtn = h('button', { className: 'btn btn-primary' }, 'Save changes to file');
      saveChangesBtn.onclick = doSaveSearchEdits;
      document.getElementById('jsonSearchSaveWrap').appendChild(saveChangesBtn);

      getContent = () => getRawJsonFromIdb();
      if (applyBtn) applyBtn.style.display = 'none';
      if (hint) hint.textContent = 'Search and edit values, then save.';
      return;
    }

    let contentToShow = typeof data === 'string' ? data : '';
    if (jsonEditorContent !== null) contentToShow = jsonEditorContent;
    getContent = () => (textareaRef && textareaRef.value) || contentToShow;
    const panelInner = h('div', { className: 'json-editor-panel' });
    textareaRef = document.createElement('textarea');
    textareaRef.className = 'json-editor-textarea';
    textareaRef.value = contentToShow;
    textareaRef.spellcheck = false;
    textareaRef.placeholder = 'Edit the JSON. Use Apply to re-analyze, Save as .sav to download in game format.';
    textareaRef.addEventListener('input', () => { jsonEditorContent = textareaRef.value; msgEl.style.display = 'none'; });
    panelInner.appendChild(textareaRef);
    panel.appendChild(panelInner);

    if (applyBtn) { applyBtn.style.display = 'inline-block'; applyBtn.onclick = doApply; }
    if (hint) hint.textContent = 'Re-analyze with the JSON below.';
  }).catch(err => {
    panel.innerHTML = '';
    panel.appendChild(h('div', { className: 'json-editor-empty', style: 'padding:2rem;color:var(--gray-500);text-align:center' },
      'Could not load saved JSON: ' + (err && err.message ? err.message : 'Unknown error')
    ));
    const saveBtn = document.getElementById('jsonEditorSaveBtn');
    const applyBtn = document.getElementById('jsonEditorApplyBtn');
    const removeBtnErr = document.getElementById('jsonEditorRemoveUserCreatedBtn');
    if (saveBtn) saveBtn.style.display = 'none';
    if (applyBtn) applyBtn.style.display = 'none';
    if (removeBtnErr) removeBtnErr.style.display = 'none';
  });
}

// ===== Storage Tab =====
function renderStorageTab(container) {
  const items = analysisData.storage;
  const totalStored = analysisData.totals.storedItems;

  let filtered = items;
  if (storageSearch) {
    const q = storageSearch.toLowerCase();
    filtered = filtered.filter(i => i.name.toLowerCase().includes(q));
  }

  filtered = [...filtered].sort((a, b) => {
    let cmp;
    if (storageSortField === 'name') cmp = a.name.localeCompare(b.name);
    else cmp = a.count - b.count;
    return storageSortDir === 'asc' ? cmp : -cmp;
  });

  const filteredTotal = filtered.reduce((sum, i) => sum + i.count, 0);

  // Toolbar
  const toolbar = h('div', { className: 'toolbar' },
    createSearchBar(storageSearch, val => { storageSearch = val; renderTabContent(); }, 'Search stored items...'),
    h('div', { className: 'toolbar-stats' },
      h('span', { className: 'stat-value color-amber' }, String(filtered.length)),
      ' types \u00B7 ',
      h('span', { style: 'color:var(--gray-200)' }, filteredTotal.toLocaleString()),
      ' total items',
      storageSearch ? ` (${totalStored.toLocaleString()} unfiltered)` : ''
    )
  );
  container.appendChild(toolbar);

  // Table
  const panel = h('div', { className: 'panel' });
  const table = document.createElement('table');

  const thead = document.createElement('thead');
  const headerRow = document.createElement('tr');
  headerRow.innerHTML = `
    <th class="left" data-field="name">Item ${sortIconHTML('name', storageSortField, storageSortDir)}</th>
    <th class="right" data-field="count">Quantity ${sortIconHTML('count', storageSortField, storageSortDir)}</th>`;
  headerRow.querySelectorAll('th').forEach(th => {
    th.addEventListener('click', () => {
      const field = th.dataset.field;
      if (storageSortField === field) {
        storageSortDir = storageSortDir === 'asc' ? 'desc' : 'asc';
      } else {
        storageSortField = field;
        storageSortDir = field === 'count' ? 'desc' : 'asc';
      }
      renderTabContent();
    });
  });
  thead.appendChild(headerRow);
  table.appendChild(thead);

  const tbody = document.createElement('tbody');
  tbody.className = 'divide';
  for (const item of filtered) {
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td class="left" style="color:var(--gray-100);font-weight:500"><span class="name-with-icon">${itemIconHTML(item.name)}${esc(item.name)}</span></td>
      <td class="right mono color-amber">${item.count.toLocaleString()}</td>`;
    tbody.appendChild(tr);
  }
  table.appendChild(tbody);
  panel.appendChild(table);

  if (filtered.length === 0) {
    panel.appendChild(h('div', { className: 'empty-msg' }, 'No items match your search'));
  }

  container.appendChild(panel);
}

// ===== Inventory Tab (character/player inventory from itemsStoreState or fragmentValues) =====
function renderInventoryTab(container) {
  const items = analysisData.inventory || [];
  const totalItems = analysisData.totals.inventoryItems || 0;

  let filtered = items;
  if (inventorySearch) {
    const q = inventorySearch.toLowerCase();
    filtered = filtered.filter(i => i.name.toLowerCase().includes(q));
  }

  filtered = [...filtered].sort((a, b) => {
    let cmp;
    if (inventorySortField === 'name') cmp = a.name.localeCompare(b.name);
    else cmp = a.count - b.count;
    return inventorySortDir === 'asc' ? cmp : -cmp;
  });

  const filteredTotal = filtered.reduce((sum, i) => sum + i.count, 0);

  const toolbar = h('div', { className: 'toolbar' },
    createSearchBar(inventorySearch, val => { inventorySearch = val; renderTabContent(); }, 'Search inventory...'),
    h('div', { className: 'toolbar-stats' },
      h('span', { className: 'stat-value', style: 'color:#a78bfa' }, String(filtered.length)),
      ' types \u00B7 ',
      h('span', { style: 'color:var(--gray-200)' }, filteredTotal.toLocaleString()),
      ' total items',
      inventorySearch ? ` (${totalItems.toLocaleString()} unfiltered)` : ''
    )
  );
  container.appendChild(toolbar);

  const panel = h('div', { className: 'panel' });
  const table = document.createElement('table');

  const thead = document.createElement('thead');
  const headerRow = document.createElement('tr');
  headerRow.innerHTML = `
    <th class="left" data-field="name">Item ${sortIconHTML('name', inventorySortField, inventorySortDir)}</th>
    <th class="right" data-field="count">Quantity ${sortIconHTML('count', inventorySortField, inventorySortDir)}</th>`;
  headerRow.querySelectorAll('th').forEach(th => {
    th.addEventListener('click', () => {
      const field = th.dataset.field;
      if (inventorySortField === field) {
        inventorySortDir = inventorySortDir === 'asc' ? 'desc' : 'asc';
      } else {
        inventorySortField = field;
        inventorySortDir = field === 'count' ? 'desc' : 'asc';
      }
      renderTabContent();
    });
  });
  thead.appendChild(headerRow);
  table.appendChild(thead);

  const tbody = document.createElement('tbody');
  tbody.className = 'divide';
  for (const item of filtered) {
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td class="left" style="color:var(--gray-100);font-weight:500"><span class="name-with-icon">${itemIconHTML(item.name)}${esc(item.name)}</span></td>
      <td class="right mono" style="color:#a78bfa">${item.count.toLocaleString()}</td>`;
    tbody.appendChild(tr);
  }
  table.appendChild(tbody);
  panel.appendChild(table);

  if (filtered.length === 0) {
    panel.appendChild(h('div', { className: 'empty-msg' },
      items.length === 0 ? 'No character inventory found in this save (itemsStoreState / fragmentValues).' : 'No items match your search.'
    ));
  }

  container.appendChild(panel);
}

// ===== Package transport Tab (sender  receiver connections, filter by item) =====
function renderDronesTab(container) {
  const connections = analysisData.transportConnections || [];
  const itemNames = [...new Set(connections.map(c => c.itemDisplayName))].filter(Boolean).sort();

  let filtered = connections;
  if (dronesItemFilter != null && dronesItemFilter !== '') {
    filtered = connections.filter(c => c.itemDisplayName === dronesItemFilter);
  }

  const toolbar = h('div', { className: 'toolbar' },
    h('div', { className: 'toolbar-stats' },
      h('span', { className: 'stat-value', style: 'color:#06b6d4' }, String(filtered.length)),
      ' connections',
      dronesItemFilter ? `  carrying ${esc(dronesItemFilter)}` : ''
    )
  );
  container.appendChild(toolbar);

  const pills = h('div', { className: 'filter-pills' });
  const allPill = h('button', {
    className: `pill ${dronesItemFilter === null ? 'active' : ''}`,
    onclick: () => { dronesItemFilter = null; renderTabContent(); }
  }, 'All items');
  pills.appendChild(allPill);
  for (const name of itemNames) {
    const pill = document.createElement('button');
    pill.className = `pill ${dronesItemFilter === name ? 'active' : ''}`;
    pill.innerHTML = `${itemIconHTML(name)}${esc(name)}`;
    pill.addEventListener('click', () => {
      dronesItemFilter = dronesItemFilter === name ? null : name;
      renderTabContent();
    });
    pills.appendChild(pill);
  }
  container.appendChild(pills);

  const panel = h('div', { className: 'panel' });
  const table = document.createElement('table');
  const thead = document.createElement('thead');
  const headerRow = document.createElement('tr');
  headerRow.innerHTML = `
    <th class="left">Sender</th>
    <th class="left">Receiver</th>
    <th class="left">Item</th>
    <th class="right">Requested</th>`;
  thead.appendChild(headerRow);
  table.appendChild(thead);

  const tbody = document.createElement('tbody');
  tbody.className = 'divide';
  for (const conn of filtered) {
    const tr = document.createElement('tr');
    const itemCell = `<span class="name-with-icon">${itemIconHTML(conn.itemDisplayName)}${esc(conn.itemDisplayName)}</span>`;
    tr.innerHTML = `
      <td class="left" style="color:var(--gray-200)">${esc(conn.senderName)}</td>
      <td class="left" style="color:var(--gray-200)">${esc(conn.receiverName)}</td>
      <td class="left" style="color:var(--gray-100)">${itemCell}</td>
      <td class="right mono" style="color:var(--gray-300)">${conn.requestedAmount > 0 ? conn.requestedAmount.toLocaleString() : ''}</td>`;
    tbody.appendChild(tr);
  }
  table.appendChild(tbody);
  panel.appendChild(table);

  if (filtered.length === 0) {
    panel.appendChild(h('div', { className: 'empty-msg' },
      dronesItemFilter ? `No connections carrying "${esc(dronesItemFilter)}".` : 'No package transport connections in this save.'
    ));
  }

  container.appendChild(panel);
}

// ===== Map Tab (StarRuptureMap-style: fixed viewBox, base map, transport lines) =====
let mapDronesItemFilter = null;
let mapDroneCarrierItemFilter = null;
function renderMapTab(container) {
  const positions = analysisData.buildingPositions || [];
  const transportConnections = analysisData.transportConnections || [];
  if (positions.length === 0) {
    container.appendChild(h('div', { className: 'empty-msg' }, 'No building location data in this save.'));
    return;
  }

  const vbMinX = 0;
  const vbMinY = 0;
  const vbW = MAP_CONTENT_WIDTH;
  const vbH = MAP_CONTENT_HEIGHT;
  const viewCenterX = vbW / 2;
  const viewCenterY = vbH / 2;

  const layout = h('div', { className: 'map-layout' });

  const wrapper = h('div', { className: 'map-wrapper' });
  const toolbar = h('div', { className: 'map-toolbar' });
  const resetBtn = document.createElement('button');
  resetBtn.textContent = 'Reset view';
  resetBtn.addEventListener('click', () => {
    mapScale = 1;
    mapTranslateX = 0;
    mapTranslateY = 0;
    renderTabContent();
  });
  toolbar.appendChild(resetBtn);
  const viewRadioWrap = h('div', { className: 'map-view-radio' });
  const buildingsRadio = document.createElement('input');
  buildingsRadio.type = 'radio';
  buildingsRadio.name = 'mapView';
  buildingsRadio.id = 'mapViewBuildings';
  buildingsRadio.checked = (mapViewMode === 'buildings');
  buildingsRadio.addEventListener('change', () => { mapViewMode = 'buildings'; renderTabContent(); });
  const prodRadio = document.createElement('input');
  prodRadio.type = 'radio';
  prodRadio.name = 'mapView';
  prodRadio.id = 'mapViewProduction';
  prodRadio.checked = (mapViewMode === 'production');
  prodRadio.addEventListener('change', () => {
    mapViewMode = 'production';
    const positions = analysisData.buildingPositions || [];
    const productionCategories = new Set(['Ore Processing', 'Extraction', 'Crafting']);
    positions.forEach(p => {
      if (productionCategories.has(p.category)) mapBuildingVisibility[p.name] = true;
    });
    renderTabContent();
  });
  const buildingsLabel = document.createElement('label');
  buildingsLabel.htmlFor = 'mapViewBuildings';
  buildingsLabel.textContent = 'Buildings';
  const prodLabel = document.createElement('label');
  prodLabel.htmlFor = 'mapViewProduction';
  prodLabel.textContent = 'Production';
  viewRadioWrap.appendChild(buildingsRadio);
  viewRadioWrap.appendChild(buildingsLabel);
  viewRadioWrap.appendChild(prodRadio);
  viewRadioWrap.appendChild(prodLabel);
  toolbar.appendChild(viewRadioWrap);
  wrapper.appendChild(toolbar);

  const mapDiv = h('div', { className: 'map-container', id: 'mapContainer' });
  const svgNs = 'http://www.w3.org/2000/svg';
  const svg = document.createElementNS(svgNs, 'svg');
  svg.setAttribute('viewBox', `${vbMinX} ${vbMinY} ${vbW} ${vbH}`);
  svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');

  const g = document.createElementNS(svgNs, 'g');
  g.id = 'mapPanZoom';
  g.setAttribute('transform', `translate(${mapTranslateX},${mapTranslateY}) scale(${mapScale})`);

  const img = document.createElementNS(svgNs, 'image');
  img.setAttribute('href', BASE_MAP_URL);
  img.setAttribute('x', -MAP_DST_X1);
  img.setAttribute('y', -MAP_DST_Y1);
  img.setAttribute('width', MAP_IMAGE_WIDTH);
  img.setAttribute('height', MAP_IMAGE_HEIGHT);
  img.setAttribute('opacity', '0.85');
  g.appendChild(img);

  const linesGrp = document.createElementNS(svgNs, 'g');
  linesGrp.id = 'mapTransportLines';
  (analysisData.transportConnections || []).forEach(conn => {
    const s = worldToMapCoords(conn.senderPos.x, conn.senderPos.y);
    const r = worldToMapCoords(conn.receiverPos.x, conn.receiverPos.y);
    const line = document.createElementNS(svgNs, 'line');
    line.setAttribute('x1', s.x);
    line.setAttribute('y1', s.y);
    line.setAttribute('x2', r.x);
    line.setAttribute('y2', r.y);
    line.setAttribute('stroke', '#8080ff');
    line.setAttribute('stroke-width', '2');
    line.setAttribute('stroke-opacity', '0.7');
    line.setAttribute('data-layer', 'transport');
    line.setAttribute('data-item', conn.itemDisplayName || '');
    linesGrp.appendChild(line);
  });
  function setDroneLinesVisibility() {
    const grp = document.getElementById('mapTransportLines');
    if (!grp) return;
    if (mapViewMode === 'production') {
      grp.style.display = 'none';
      return;
    }
    grp.style.display = '';
    for (let i = 0; i < grp.children.length; i++) {
      const line = grp.children[i];
      const item = line.getAttribute('data-item');
      line.style.display = (mapDronesItemFilter == null || mapDronesItemFilter === '' || item === mapDronesItemFilter) ? '' : 'none';
    }
  }
  if (mapViewMode === 'production') {
    linesGrp.style.display = 'none';
  } else {
    linesGrp.style.display = '';
    for (let i = 0; i < linesGrp.children.length; i++) {
      const line = linesGrp.children[i];
      const item = line.getAttribute('data-item');
      line.style.display = (mapDronesItemFilter == null || mapDronesItemFilter === '' || item === mapDronesItemFilter) ? '' : 'none';
    }
  }
  g.appendChild(linesGrp);

  const droneCarriers = analysisData.droneCarriers || [];
  const droneMarkersGrp = document.createElementNS(svgNs, 'g');
  droneMarkersGrp.id = 'mapDroneCarrierMarkers';
  droneCarriers.forEach(d => {
    const m = worldToMapCoords(d.x, d.y);
    const circle = document.createElementNS(svgNs, 'circle');
    circle.setAttribute('cx', m.x);
    circle.setAttribute('cy', m.y);
    circle.setAttribute('r', 6);
    circle.setAttribute('fill', '#06b6d4');
    circle.setAttribute('stroke', '#0e7490');
    circle.setAttribute('stroke-width', '1.5');
    circle.setAttribute('data-item', d.itemDisplayName || '');
    circle.setAttribute('opacity', '0.9');
    droneMarkersGrp.appendChild(circle);
  });
  const MAP_CARRIER_SHOW_ALL = '\u200b**all**'; // sentinel for "show all" drone markers
  function setDroneCarrierMarkersVisibility() {
    const grp = document.getElementById('mapDroneCarrierMarkers');
    if (!grp) return;
    if (mapViewMode === 'production' || mapDroneCarrierItemFilter == null || mapDroneCarrierItemFilter === '') {
      grp.style.display = 'none';
      return;
    }
    grp.style.display = '';
    const showAll = (mapDroneCarrierItemFilter === MAP_CARRIER_SHOW_ALL);
    for (let i = 0; i < grp.children.length; i++) {
      const el = grp.children[i];
      el.style.display = (showAll || el.getAttribute('data-item') === mapDroneCarrierItemFilter) ? '' : 'none';
    }
  }
  if (mapViewMode === 'production' || mapDroneCarrierItemFilter == null || mapDroneCarrierItemFilter === '') {
    droneMarkersGrp.style.display = 'none';
  } else {
    droneMarkersGrp.style.display = '';
    const showAll = (mapDroneCarrierItemFilter === MAP_CARRIER_SHOW_ALL);
    for (let i = 0; i < droneMarkersGrp.children.length; i++) {
      const el = droneMarkersGrp.children[i];
      el.style.display = (showAll || el.getAttribute('data-item') === mapDroneCarrierItemFilter) ? '' : 'none';
    }
  }
  g.appendChild(droneMarkersGrp);

  const buildingRectsGrp = document.createElementNS(svgNs, 'g');
  buildingRectsGrp.id = 'mapBuildingRects';
  buildingRectsGrp.style.display = '';

  const MAP_PRODUCTION_CATEGORIES = new Set(['Ore Processing', 'Extraction', 'Crafting']);
  const byName = {};
  positions.forEach(p => {
    byName[p.name] = (byName[p.name] || 0) + 1;
  });
  // Initialize visibility: by default only Crafting is enabled
  positions.forEach(p => {
    if (mapBuildingVisibility[p.name] === undefined) {
      mapBuildingVisibility[p.name] = (p.category === MAP_DEFAULT_VISIBLE_CATEGORY);
    }
  });
  const mapSpan = Math.min(vbW, vbH);
  const minSize = 2;
  const maxSize = mapSpan * 0.015;
  function setRectVisibility(grp, visibilityMap) {
    for (let i = 0; i < grp.children.length; i++) {
      const el = grp.children[i];
      const name = el.getAttribute('data-name');
      const category = el.getAttribute('data-category');
      const areaIdStr = el.getAttribute('data-area-id');
      const areaId = areaIdStr != null ? Number(areaIdStr) : null;
      if (name == null) continue;
      if (mapViewMode === 'production') {
        const areaVisible = areaId != null && mapAreaVisibility[areaId] !== false;
        el.style.display = (MAP_PRODUCTION_CATEGORIES.has(category) && areaVisible) ? '' : 'none';
      } else {
        el.style.display = visibilityMap[name] !== false ? '' : 'none';
      }
    }
  }
  positions.forEach(p => {
    const m = worldToMapCoords(p.x, p.y);
    const size = Math.max(minSize, Math.min(maxSize, mapSizeForBuilding(p.name)));
    const rect = document.createElementNS(svgNs, 'rect');
    rect.setAttribute('x', m.x - size / 2);
    rect.setAttribute('y', m.y - size / 2);
    rect.setAttribute('width', size);
    rect.setAttribute('height', size);
    rect.setAttribute('fill', hashColor(p.name));
    rect.setAttribute('stroke', 'rgba(0,0,0,0.5)');
    rect.setAttribute('stroke-width', '0.5');
    rect.setAttribute('data-name', p.name);
    rect.setAttribute('data-category', p.category);
    if (p.areaId != null) rect.setAttribute('data-area-id', String(p.areaId));
    rect.style.cursor = 'pointer';
    rect.style.display = mapViewMode === 'production'
      ? (p.areaId != null && MAP_PRODUCTION_CATEGORIES.has(p.category) && mapAreaVisibility[p.areaId] !== false ? '' : 'none')
      : (mapBuildingVisibility[p.name] !== false ? '' : 'none');
    buildingRectsGrp.appendChild(rect);
  });
  g.appendChild(buildingRectsGrp);

  const productionByArea = analysisData.productionByArea || [];
  productionByArea.forEach(a => {
    if (mapAreaVisibility[a.id] === undefined) mapAreaVisibility[a.id] = true;
  });
  const areaMarkersGrp = document.createElementNS(svgNs, 'g');
  areaMarkersGrp.id = 'mapAreaMarkers';
  areaMarkersGrp.style.display = mapViewMode === 'production' ? '' : 'none';
  const halfExt = BASE_CORE_BUILD_HALF_EXTENT;
  productionByArea.forEach(area => {
    if (area.x == null || area.y == null) return;
    const topLeft = worldToMapCoords(area.x - halfExt, area.y - halfExt);
    const bottomRight = worldToMapCoords(area.x + halfExt, area.y + halfExt);
    const w = bottomRight.x - topLeft.x;
    const h = bottomRight.y - topLeft.y;
    const areaGrp = document.createElementNS(svgNs, 'g');
    areaGrp.setAttribute('data-area-id', String(area.id));
    areaGrp.style.display = mapAreaVisibility[area.id] !== false ? '' : 'none';
    const rect = document.createElementNS(svgNs, 'rect');
    rect.setAttribute('x', topLeft.x);
    rect.setAttribute('y', topLeft.y);
    rect.setAttribute('width', w);
    rect.setAttribute('height', h);
    rect.setAttribute('fill', 'rgba(34,197,94,0.2)');
    rect.setAttribute('stroke', '#22c55e');
    rect.setAttribute('stroke-width', '2');
    rect.style.cursor = 'pointer';
    rect.setAttribute('pointer-events', 'all');
    rect.addEventListener('mousedown', (e) => e.stopPropagation());
    rect.addEventListener('click', (e) => {
      e.stopPropagation();
      mapHighlightedAreaId = (mapHighlightedAreaId === area.id) ? null : area.id;
      renderTabContent();
    });
    areaGrp.appendChild(rect);
    const label = document.createElementNS(svgNs, 'text');
    label.setAttribute('x', topLeft.x + w / 2);
    label.setAttribute('y', topLeft.y - 6);
    label.setAttribute('text-anchor', 'middle');
    label.setAttribute('font-size', '11');
    label.setAttribute('font-weight', '600');
    label.setAttribute('fill', '#22c55e');
    label.setAttribute('pointer-events', 'none');
    label.textContent = area.label;
    areaGrp.appendChild(label);
    areaMarkersGrp.appendChild(areaGrp);
  });
  g.appendChild(areaMarkersGrp);

  svg.appendChild(g);
  mapDiv.appendChild(svg);

  const hoverLabel = document.createElement('div');
  hoverLabel.className = 'map-hover-label';
  hoverLabel.innerHTML = '<span class="map-hover-label-name"></span><div class="map-hover-label-cat"></div><div class="map-hover-label-produces"></div>';
  const hoverLabelName = hoverLabel.querySelector('.map-hover-label-name');
  const hoverLabelCat = hoverLabel.querySelector('.map-hover-label-cat');
  const hoverLabelProduces = hoverLabel.querySelector('.map-hover-label-produces');
  const labelOffset = 12;
  function showHoverLabel(name, category, clientX, clientY, displayName, producedItem) {
    // Line 1: always show building type (name)
    hoverLabelName.textContent = name;
    // Line 2: category; if user set a custom name, show it here too
    hoverLabelCat.textContent = (displayName && displayName !== name)
      ? `${category}  "${displayName}"`
      : category;
    if (producedItem) {
      hoverLabelProduces.textContent = `Producing: ${producedItem}`;
      hoverLabelProduces.style.display = '';
    } else {
      hoverLabelProduces.style.display = 'none';
    }
    hoverLabel.classList.add('visible');
    positionHoverLabel(clientX, clientY);
  }
  function positionHoverLabel(clientX, clientY) {
    const wr = wrapper.getBoundingClientRect();
    let left = clientX - wr.left + labelOffset;
    let top = clientY - wr.top + labelOffset;
    if (left + hoverLabel.offsetWidth > wr.width) left = clientX - wr.left - hoverLabel.offsetWidth - 4;
    if (top + hoverLabel.offsetHeight > wr.height) top = clientY - wr.top - hoverLabel.offsetHeight - 4;
    if (left < 4) left = 4;
    if (top < 4) top = 4;
    hoverLabel.style.left = left + 'px';
    hoverLabel.style.top = top + 'px';
  }
  function hideHoverLabel() {
    hoverLabel.classList.remove('visible');
  }
  positions.forEach((p, i) => {
    const rect = buildingRectsGrp.children[i];
    if (!rect) return;
    rect.addEventListener('mouseenter', (e) => {
      showHoverLabel(p.name, p.category, e.clientX, e.clientY, p.displayName, p.producedItem);
    });
    rect.addEventListener('mousemove', (e) => {
      positionHoverLabel(e.clientX, e.clientY);
    });
    rect.addEventListener('mouseleave', hideHoverLabel);
  });
  const areaById = new Map(productionByArea.map(a => [String(a.id), a]));
  for (let i = 0; i < areaMarkersGrp.children.length; i++) {
    const areaEl = areaMarkersGrp.children[i];
    const area = areaById.get(areaEl.getAttribute('data-area-id'));
    if (!area) continue;
    areaEl.addEventListener('mouseenter', (e) => {
      hoverLabelName.textContent = area.label;
      hoverLabelCat.textContent = area.items.length + ' items \u00B7 ' + area.totalPerMinute.toFixed(1) + '/min total';
      hoverLabelProduces.style.display = 'none';
      hoverLabel.classList.add('visible');
      positionHoverLabel(e.clientX, e.clientY);
    });
    areaEl.addEventListener('mousemove', (e) => positionHoverLabel(e.clientX, e.clientY));
    areaEl.addEventListener('mouseleave', hideHoverLabel);
  }
  mapDiv.addEventListener('mousemove', (e) => {
    if (hoverLabel.classList.contains('visible')) positionHoverLabel(e.clientX, e.clientY);
  });
  wrapper.appendChild(mapDiv);
  wrapper.appendChild(hoverLabel);
  layout.appendChild(wrapper);

  let isDragging = false;
  let startX, startY, startTx, startTy;

  function pixelToViewBox(deltaPx, deltaPy) {
    const rect = mapDiv.getBoundingClientRect();
    if (rect.width <= 0 || rect.height <= 0) return { dx: 0, dy: 0 };
    const fitScale = Math.min(rect.width / vbW, rect.height / vbH);
    return { dx: deltaPx / fitScale, dy: deltaPy / fitScale };
  }

  function updateMapTransform() {
    const el = document.getElementById('mapPanZoom');
    if (el) el.setAttribute('transform', `translate(${mapTranslateX},${mapTranslateY}) scale(${mapScale})`);
  }

  mapDiv.addEventListener('mousedown', (e) => {
    if (e.button !== 0) return;
    e.preventDefault();
    isDragging = true;
    startX = e.clientX;
    startY = e.clientY;
    startTx = mapTranslateX;
    startTy = mapTranslateY;
  });
  mapDiv.addEventListener('mousemove', (e) => {
    if (!isDragging) return;
    e.preventDefault();
    const delta = pixelToViewBox(e.clientX - startX, e.clientY - startY);
    mapTranslateX = startTx + delta.dx;
    mapTranslateY = startTy + delta.dy;
    updateMapTransform();
  });
  document.addEventListener('mouseup', () => { isDragging = false; });
  mapDiv.addEventListener('mouseleave', () => { isDragging = false; });
  mapDiv.addEventListener('wheel', (e) => {
    e.preventDefault();
    const factor = e.deltaY > 0 ? 0.9 : 1.1;
    const newScale = Math.max(0.2, Math.min(20, mapScale * factor));
    if (newScale !== mapScale) {
      mapTranslateX = mapTranslateX + (1 - newScale / mapScale) * (viewCenterX - mapTranslateX);
      mapTranslateY = mapTranslateY + (1 - newScale / mapScale) * (viewCenterY - mapTranslateY);
      mapScale = newScale;
      updateMapTransform();
    }
  }, { passive: false });

  if (mapViewMode === 'production' && productionByArea.length > 0) {
    const prodPanel = h('div', { className: 'map-legend map-production-by-area' });
    const prodHeader = document.createElement('div');
    prodHeader.className = 'map-legend-header';
    const prodTitle = document.createElement('h3');
    prodTitle.textContent = 'Production by area';
    prodHeader.appendChild(prodTitle);
    prodPanel.appendChild(prodHeader);
    const searchWrap = document.createElement('div');
    searchWrap.className = 'map-production-search-wrap';
    const searchInput = document.createElement('input');
    searchInput.type = 'text';
    searchInput.className = 'map-production-search';
    searchInput.placeholder = 'Filter by item...';
    searchInput.value = productionAreaSearch;
    function applyProductionAreaFilter() {
      const q = productionAreaSearch.trim().toLowerCase();
      prodPanel.querySelectorAll('.map-production-area-section').forEach(section => {
        const id = section.getAttribute('data-area-id');
        const area = productionByArea.find(a => String(a.id) === id);
        const match = !q || (area && area.items.some(it => it.name.toLowerCase().includes(q)));
        section.style.display = match ? '' : 'none';
      });
    }
    function updateProductionFilterFromSearch() {
      const q = productionAreaSearch.trim().toLowerCase();
      productionByArea.forEach(area => {
        const match = !q || area.items.some(it => it.name.toLowerCase().includes(q));
        mapAreaVisibility[area.id] = match;
      });
      prodPanel.querySelectorAll('.map-production-area-section').forEach(section => {
        const id = section.getAttribute('data-area-id');
        const area = productionByArea.find(a => String(a.id) === id);
        const match = !q || (area && area.items.some(it => it.name.toLowerCase().includes(q)));
        section.style.display = match ? '' : 'none';
        const cb = section.querySelector('input[type="checkbox"]');
        if (cb && area != null) cb.checked = mapAreaVisibility[area.id] !== false;
      });
      const areaMarkersGrp = document.getElementById('mapAreaMarkers');
      if (areaMarkersGrp) {
        for (let i = 0; i < areaMarkersGrp.children.length; i++) {
          const el = areaMarkersGrp.children[i];
          const areaId = el.getAttribute('data-area-id');
          if (areaId != null) el.style.display = mapAreaVisibility[areaId] !== false ? '' : 'none';
        }
      }
      const buildingRectsGrp = document.getElementById('mapBuildingRects');
      if (buildingRectsGrp && mapViewMode === 'production') {
        for (let i = 0; i < buildingRectsGrp.children.length; i++) {
          const el = buildingRectsGrp.children[i];
          const areaIdStr = el.getAttribute('data-area-id');
          const category = el.getAttribute('data-category');
          const areaVisible = areaIdStr != null && mapAreaVisibility[areaIdStr] !== false;
          const show = areaVisible && MAP_PRODUCTION_CATEGORIES.has(category);
          el.style.display = show ? '' : 'none';
        }
      }
    }
    searchInput.addEventListener('input', () => {
      productionAreaSearch = searchInput.value;
      updateProductionFilterFromSearch();
    });
    searchWrap.appendChild(searchInput);
    prodPanel.appendChild(searchWrap);
    productionByArea.forEach(area => {
      const areaSection = document.createElement('div');
      areaSection.className = 'map-production-area-section' + (mapAreaVisibility[area.id] === false ? ' area-disabled' : '') + (mapHighlightedAreaId === area.id ? ' area-highlighted' : '');
      areaSection.setAttribute('data-area-id', String(area.id));
      const areaRow = document.createElement('label');
      areaRow.className = 'map-production-area-toggle';
      const areaCb = document.createElement('input');
      areaCb.type = 'checkbox';
      areaCb.checked = mapAreaVisibility[area.id] !== false;
      areaCb.addEventListener('change', () => {
        mapAreaVisibility[area.id] = areaCb.checked;
        renderTabContent();
      });
      const areaTitle = document.createElement('span');
      areaTitle.className = 'map-production-area-title';
      areaTitle.textContent = area.label;
      areaRow.appendChild(areaCb);
      areaRow.appendChild(areaTitle);
      areaSection.appendChild(areaRow);
      const areaBody = document.createElement('div');
      areaBody.className = 'map-production-area-body';
      const areaTotal = document.createElement('div');
      areaTotal.className = 'map-production-area-total';
      areaTotal.textContent = area.totalPerMinute.toFixed(1) + ' items/min total';
      areaBody.appendChild(areaTotal);
      if (area.items.length > 0) {
        const table = document.createElement('table');
        table.className = 'map-production-area-table';
        const thead = document.createElement('thead');
        thead.innerHTML = '<tr><th class="left">Item</th><th class="right">Produced</th><th class="right">Sent</th></tr>';
        table.appendChild(thead);
        const tbody = document.createElement('tbody');
        tbody.className = 'divide';
        area.items.forEach(({ name, produced, sent }) => {
          const tr = document.createElement('tr');
          const sentClass = sent > 0 ? ' right rate-deficit' : ' right';
          tr.innerHTML = `<td class="left">${itemIconHTML(name)} ${esc(name)}</td><td class="right">${produced.toFixed(2)}</td><td class="${sentClass}">${sent > 0 ? sent.toFixed(2) : ''}</td>`;
          tbody.appendChild(tr);
        });
        table.appendChild(tbody);
        areaBody.appendChild(table);
      }
      areaSection.appendChild(areaBody);
      prodPanel.appendChild(areaSection);
    });
    applyProductionAreaFilter();
    layout.appendChild(prodPanel);
    if (mapHighlightedAreaId != null) {
      const highlightedEl = prodPanel.querySelector('[data-area-id="' + mapHighlightedAreaId + '"]');
      if (highlightedEl) {
        requestAnimationFrame(() => {
          highlightedEl.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        });
      }
    }
  } else {
  const legend = h('div', { className: 'map-legend' });
  const legendHeader = document.createElement('div');
  legendHeader.className = 'map-legend-header';
  const legendTitle = document.createElement('h3');
  legendTitle.textContent = 'Show on map';
  legendHeader.appendChild(legendTitle);
  const allBtn = document.createElement('button');
  allBtn.className = 'map-legend-toggle';
  allBtn.textContent = 'All';
  allBtn.title = 'Show all building types';
  const noneBtn = document.createElement('button');
  noneBtn.className = 'map-legend-toggle';
  noneBtn.textContent = 'None';
  noneBtn.title = 'Hide all building types';
  legendHeader.appendChild(allBtn);
  legendHeader.appendChild(noneBtn);
  legend.appendChild(legendHeader);
  if (transportConnections.length > 0) {
    const droneCatDiv = document.createElement('div');
    droneCatDiv.className = 'map-legend-cat map-legend-cat-collapsible collapsed';
    const droneCatHead = document.createElement('div');
    droneCatHead.className = 'map-legend-cat-head';
    const droneChevron = document.createElement('span');
    droneChevron.className = 'map-legend-cat-chevron';
    droneChevron.innerHTML = '<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M7 10l5 5 5-5"/></svg>';
    droneChevron.setAttribute('aria-label', 'Collapse section');
    droneChevron.addEventListener('click', (e) => { e.stopPropagation(); droneCatDiv.classList.toggle('collapsed'); });
    const droneCatTitle = document.createElement('span');
    droneCatTitle.className = 'map-legend-cat-title';
    droneCatTitle.textContent = 'Package transport (' + transportConnections.length + ' connections)';
    droneCatHead.appendChild(droneChevron);
    droneCatHead.appendChild(droneCatTitle);
    droneCatDiv.appendChild(droneCatHead);

    const droneCatBody = document.createElement('div');
    droneCatBody.className = 'map-legend-cat-body';
    const droneFilterLabel = document.createElement('div');
    droneFilterLabel.className = 'map-legend-cat-title';
    droneFilterLabel.style.marginTop = '0.35rem';
    droneFilterLabel.style.marginBottom = '0.25rem';
    droneFilterLabel.textContent = 'Filter by item:';
    droneCatBody.appendChild(droneFilterLabel);

    const dronePillsWrap = document.createElement('div');
    dronePillsWrap.className = 'filter-pills';
    dronePillsWrap.style.marginBottom = '0.5rem';

    const allDronePill = document.createElement('button');
    allDronePill.className = 'pill map-legend-drones-pill' + (mapDronesItemFilter === null ? ' active' : '');
    allDronePill.dataset.item = 'all';
    allDronePill.textContent = 'All';
    allDronePill.addEventListener('click', () => {
      mapDronesItemFilter = null;
      setDroneLinesVisibility();
      droneCatDiv.querySelectorAll('.map-legend-drones-pill').forEach(p => {
        p.classList.toggle('active', p.dataset.item === 'all');
      });
    });
    dronePillsWrap.appendChild(allDronePill);

    const mapDroneItems = [...new Set(transportConnections.map(c => c.itemDisplayName))].filter(Boolean).sort();
    mapDroneItems.forEach(itemName => {
      const pill = document.createElement('button');
      pill.className = 'pill map-legend-drones-pill' + (mapDronesItemFilter === itemName ? ' active' : '');
      pill.dataset.item = itemName;
      pill.innerHTML = `${itemIconHTML(itemName)}${esc(itemName)}`;
      pill.style.fontSize = '0.75rem';
      pill.addEventListener('click', () => {
        mapDronesItemFilter = mapDronesItemFilter === itemName ? null : itemName;
        setDroneLinesVisibility();
        droneCatDiv.querySelectorAll('.map-legend-drones-pill').forEach(p => {
          p.classList.toggle('active', (p.dataset.item === 'all' && mapDronesItemFilter === null) || p.dataset.item === mapDronesItemFilter);
        });
      });
      dronePillsWrap.appendChild(pill);
    });
    droneCatBody.appendChild(dronePillsWrap);
    droneCatDiv.appendChild(droneCatBody);
    legend.appendChild(droneCatDiv);
  }

  if (droneCarriers.length > 0) {
    const carrierCatDiv = document.createElement('div');
    carrierCatDiv.className = 'map-legend-cat map-legend-cat-collapsible collapsed';
    const carrierHead = document.createElement('div');
    carrierHead.className = 'map-legend-cat-head';
    carrierHead.style.cursor = 'pointer';
    const carrierChevron = document.createElement('span');
    carrierChevron.className = 'map-legend-cat-chevron';
    carrierChevron.innerHTML = '<svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M7 10l5 5 5-5"/></svg>';
    carrierChevron.setAttribute('aria-label', 'Collapse section');
    const carrierTitle = document.createElement('span');
    carrierTitle.className = 'map-legend-cat-title';
    carrierTitle.style.marginBottom = '0';
    carrierTitle.textContent = 'Drones in transit (carrying item):';
    carrierHead.appendChild(carrierChevron);
    carrierHead.appendChild(carrierTitle);
    carrierHead.addEventListener('click', () => carrierCatDiv.classList.toggle('collapsed'));
    carrierCatDiv.appendChild(carrierHead);

    const carrierBody = document.createElement('div');
    carrierBody.className = 'map-legend-cat-body';
    const carrierHint = document.createElement('div');
    carrierHint.className = 'map-legend-cat-title';
    carrierHint.style.fontSize = '0.7rem';
    carrierHint.style.color = 'var(--gray-500)';
    carrierHint.style.marginBottom = '0.35rem';
    carrierHint.style.marginTop = '0.25rem';
    carrierHint.textContent = 'Select item to show drones carrying it';
    carrierBody.appendChild(carrierHint);
    const carrierPillsWrap = document.createElement('div');
    carrierPillsWrap.className = 'filter-pills';
    carrierPillsWrap.style.marginBottom = '0.5rem';

    function isCarrierPillActive(datasetItem) {
      return (datasetItem === '' && mapDroneCarrierItemFilter === null) ||
        (datasetItem === MAP_CARRIER_SHOW_ALL && mapDroneCarrierItemFilter === MAP_CARRIER_SHOW_ALL) ||
        datasetItem === mapDroneCarrierItemFilter;
    }

    const carrierAllPill = document.createElement('button');
    carrierAllPill.className = 'pill map-legend-carrier-pill' + (mapDroneCarrierItemFilter === MAP_CARRIER_SHOW_ALL ? ' active' : '');
    carrierAllPill.dataset.item = MAP_CARRIER_SHOW_ALL;
    carrierAllPill.textContent = 'All';
    carrierAllPill.addEventListener('click', () => {
      mapDroneCarrierItemFilter = MAP_CARRIER_SHOW_ALL;
      setDroneCarrierMarkersVisibility();
      carrierCatDiv.querySelectorAll('.map-legend-carrier-pill').forEach(p => {
        p.classList.toggle('active', isCarrierPillActive(p.dataset.item));
      });
    });
    carrierPillsWrap.appendChild(carrierAllPill);

    const carrierNonePill = document.createElement('button');
    carrierNonePill.className = 'pill map-legend-carrier-pill' + (mapDroneCarrierItemFilter === null ? ' active' : '');
    carrierNonePill.dataset.item = '';
    carrierNonePill.textContent = 'None';
    carrierNonePill.addEventListener('click', () => {
      mapDroneCarrierItemFilter = null;
      setDroneCarrierMarkersVisibility();
      carrierCatDiv.querySelectorAll('.map-legend-carrier-pill').forEach(p => {
        p.classList.toggle('active', isCarrierPillActive(p.dataset.item));
      });
    });
    carrierPillsWrap.appendChild(carrierNonePill);

    const carrierItems = [...new Set(droneCarriers.map(d => d.itemDisplayName))].filter(Boolean).sort();
    carrierItems.forEach(itemName => {
      const pill = document.createElement('button');
      pill.className = 'pill map-legend-carrier-pill' + (mapDroneCarrierItemFilter === itemName ? ' active' : '');
      pill.dataset.item = itemName;
      pill.innerHTML = `${itemIconHTML(itemName)}${esc(itemName)}`;
      pill.style.fontSize = '0.75rem';
      pill.addEventListener('click', () => {
        mapDroneCarrierItemFilter = mapDroneCarrierItemFilter === itemName ? null : itemName;
        setDroneCarrierMarkersVisibility();
        carrierCatDiv.querySelectorAll('.map-legend-carrier-pill').forEach(p => {
          p.classList.toggle('active', isCarrierPillActive(p.dataset.item));
        });
      });
      carrierPillsWrap.appendChild(pill);
    });
    carrierBody.appendChild(carrierPillsWrap);
    carrierCatDiv.appendChild(carrierBody);
    legend.appendChild(carrierCatDiv);
  }

  const byCategory = {};
  positions.forEach(p => {
    if (!byCategory[p.category]) byCategory[p.category] = [];
    byCategory[p.category].push(p);
  });
  const catOrder = [...new Set(positions.map(p => p.category))].sort();
  function updateCategoryCheckbox(catCheckbox, catDiv) {
    const itemCheckboxes = catDiv.querySelectorAll('.map-legend-item-toggle input[type="checkbox"]');
    const checked = [...itemCheckboxes].filter(cb => cb.checked).length;
    catCheckbox.checked = checked === itemCheckboxes.length;
    catCheckbox.indeterminate = checked > 0 && checked < itemCheckboxes.length;
  }
  catOrder.forEach(cat => {
    const catDiv = document.createElement('div');
    catDiv.className = 'map-legend-cat';
    const list = byCategory[cat];
    const names = [...new Set(list.map(p => p.name))].sort();
    const catTitleRow = document.createElement('label');
    catTitleRow.className = 'map-legend-cat-title map-legend-cat-toggle';
    const catCheckbox = document.createElement('input');
    catCheckbox.type = 'checkbox';
    catCheckbox.checked = names.every(name => mapBuildingVisibility[name] !== false);
    catCheckbox.indeterminate = names.some(name => mapBuildingVisibility[name]) && !catCheckbox.checked;
    catCheckbox.addEventListener('change', () => {
      const on = catCheckbox.checked;
      list.forEach(p => { mapBuildingVisibility[p.name] = on; });
      catDiv.querySelectorAll('.map-legend-item-toggle input[type="checkbox"]').forEach(cb => { cb.checked = on; });
      catCheckbox.indeterminate = false;
      setRectVisibility(buildingRectsGrp, mapBuildingVisibility);
    });
    const catTitleText = document.createElement('span');
    catTitleText.textContent = cat;
    catTitleRow.appendChild(catCheckbox);
    catTitleRow.appendChild(catTitleText);
    catDiv.appendChild(catTitleRow);
    names.forEach(name => {
      const count = list.filter(p => p.name === name).length;
      const color = hashColor(name);
      const item = document.createElement('label');
      item.className = 'map-legend-item map-legend-item-toggle';
      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.checked = mapBuildingVisibility[name] !== false;
      checkbox.addEventListener('change', () => {
        mapBuildingVisibility[name] = checkbox.checked;
        setRectVisibility(buildingRectsGrp, mapBuildingVisibility);
        updateCategoryCheckbox(catCheckbox, catDiv);
      });
      const dot = document.createElement('span');
      dot.className = 'map-legend-dot';
      dot.style.background = color;
      const label = document.createElement('span');
      label.textContent = name;
      const countSpan = document.createElement('span');
      countSpan.className = 'map-legend-count';
      countSpan.textContent = String(count);
      item.appendChild(checkbox);
      item.appendChild(dot);
      item.appendChild(label);
      item.appendChild(countSpan);
      catDiv.appendChild(item);
    });
    legend.appendChild(catDiv);
  });
  allBtn.addEventListener('click', () => {
    positions.forEach(p => { mapBuildingVisibility[p.name] = true; });
    legend.querySelectorAll('.map-legend-item-toggle input[type="checkbox"]').forEach(cb => { cb.checked = true; });
    setRectVisibility(buildingRectsGrp, mapBuildingVisibility);
  });
  noneBtn.addEventListener('click', () => {
    positions.forEach(p => { mapBuildingVisibility[p.name] = false; });
    legend.querySelectorAll('.map-legend-item-toggle input[type="checkbox"]').forEach(cb => { cb.checked = false; });
    setRectVisibility(buildingRectsGrp, mapBuildingVisibility);
  });
  layout.appendChild(legend);
  }
  container.appendChild(layout);
}

// ===== Shared Components =====
function createSearchBar(value, onChange, placeholder) {
  const wrapper = h('div', { className: 'search-wrapper' });
  wrapper.innerHTML = `<svg class="search-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"/>
  </svg>`;

  const input = document.createElement('input');
  input.type = 'text';
  input.className = 'search-input';
  input.placeholder = placeholder;
  input.value = value;
  input.addEventListener('input', (e) => onChange(e.target.value));
  wrapper.appendChild(input);

  if (value) {
    const clearBtn = document.createElement('button');
    clearBtn.className = 'search-clear';
    clearBtn.innerHTML = `<svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
    </svg>`;
    clearBtn.addEventListener('click', () => onChange(''));
    wrapper.appendChild(clearBtn);
  }

  return wrapper;
}

function sortIconHTML(field, currentField, currentDir) {
  if (currentField !== field) {
    return `<span class="sort-icon inactive">\u2191\u2193</span>`;
  }
  return `<span class="sort-icon active">${currentDir === 'asc' ? '\u2191' : '\u2193'}</span>`;
}

function esc(str) {
  const div = document.createElement('div');
  div.textContent = str;
  return div.innerHTML;
}

// ===== Navigation =====
function goBack() {
  analysisData = null;
  activeSaveName = null;
  jsonEditorContent = null;
  activeTab = 'buildings';
  buildingsSearch = '';
  buildingsCollapsed = new Set();
  productionSearch = '';
  productionBuildingFilter = null;
  productionSortField = 'name';
  productionSortDir = 'asc';
  storageSearch = '';
  storageSortField = 'name';
  storageSortDir = 'asc';
  inventorySearch = '';
  inventorySortField = 'name';
  inventorySortDir = 'asc';

  $('#activeSaveLabel').classList.add('hidden');
  $('#tabsContainer').classList.add('hidden');

  renderPickerView();
}

function showAnalysis(data, filename) {
  analysisData = data;
  activeSaveName = filename;
  activeTab = 'buildings';

  $('#activeSaveLabel').textContent = '\u2014 ' + filename;
  $('#activeSaveLabel').classList.remove('hidden');
  $('#tabsContainer').classList.remove('hidden');

  renderAnalysisView();
}

// ===== File Handling =====
async function handleFileSelect(e) {
  const file = e.target.files[0];
  if (!file) return;
  await processFile(file);
  // Reset so the same file can be re-selected
  e.target.value = '';
}

async function processFile(file) {
  const loading = $('#loadingOverlay');
  const main = $('#mainContent');

  loading.classList.remove('hidden');

  try {
    const jsonContent = await parseSaveFile(file);
    jsonEditorContent = null;
    const result = analyze(jsonContent);
    saveRawJsonToIdb(jsonContent).catch(() => {});
    showAnalysis(result, file.name);
  } catch (err) {
    console.error('Failed to analyze save file:', err);
    main.innerHTML = '';
    main.appendChild(h('div', { className: 'error-banner' },
      `Failed to analyze save file: ${err.message}`
    ));
    const pickerWrap = document.createElement('div');
    main.appendChild(pickerWrap);
    renderPickerView(pickerWrap);
  } finally {
    loading.classList.add('hidden');
  }
}

// ===== Drag & Drop =====
document.addEventListener('dragover', (e) => {
  e.preventDefault();
  document.body.classList.add('drag-active');
});

document.addEventListener('dragleave', (e) => {
  if (e.relatedTarget === null) {
    document.body.classList.remove('drag-active');
  }
});

document.addEventListener('drop', (e) => {
  e.preventDefault();
  document.body.classList.remove('drag-active');
  const file = e.dataTransfer.files[0];
  if (file && file.name.endsWith('.sav')) {
    processFile(file);
  }
});

// ===== Init =====
renderPickerView();
</script>
</body>
</html>

